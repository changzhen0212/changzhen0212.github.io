<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"changzhen0212.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="不忘初心，方得始终">
<meta property="og:type" content="website">
<meta property="og:title" content="ChangZhen&#39;s Blog">
<meta property="og:url" content="http://changzhen0212.github.io/index.html">
<meta property="og:site_name" content="ChangZhen&#39;s Blog">
<meta property="og:description" content="不忘初心，方得始终">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ChangZhen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://changzhen0212.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ChangZhen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ChangZhen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/19/JVM/JVM-09-JVM%E5%B8%B8%E9%87%8F%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/19/JVM/JVM-09-JVM%E5%B8%B8%E9%87%8F%E6%B1%A0/" class="post-title-link" itemprop="url">常量池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-19 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-19T00:00:00+08:00">2022-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-28 00:30:22" itemprop="dateModified" datetime="2022-03-28T00:30:22+08:00">2022-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>



<p>常量池存放的是编译期生成的字面量和符号引用</p>
<ul>
<li><p>字面量：字面量就是指由字母、数字等构成的字符串或者数值常量。</p>
<ul>
<li>字面量只能以右值方式出现，就是等号右边的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    1和”abc”都是字面量。</p>
<ul>
<li>符号引用：属于编译原理方面的概念,是相对于直接引用来说的，主要包括下面几类常量：<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
上面代码中，a s 是字段名称，就是一种符号引用。</li>
</ul>
<h2 id="常量池："><a href="#常量池：" class="headerlink" title="常量池："></a>常量池：</h2><ul>
<li>静态常量池</li>
<li>运行时常量池</li>
<li>字符串常量池</li>
<li>八种数据类型的包装类常量池</li>
</ul>
<h2 id="静态常量池和运行时常量池"><a href="#静态常量池和运行时常量池" class="headerlink" title="静态常量池和运行时常量池"></a>静态常量池和运行时常量池</h2><p>上面说的字面量和符号引用，在编译成.class文件的时候以静态的形式保存，就是<strong>静态常量池</strong>。当class文件被加载到内存中，这些符号会有对应的内存地址信息，这些常量池装入内存就是<strong>运行时常量池</strong>。</p>
<p><strong>动态链接</strong>：符号引用在程序加载或者运行时被转变成内存区域代码的直接引用。</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>常量池可以理解为是一个缓存池。把相同的字符串缓存起来，下次使用直接拿</p>
<p>JVM对字符串优化：</p>
<ul>
<li>为字符串开辟一个常量池，类似缓存取</li>
<li>创建字符串常量时，先去字符串常量池用equals()判断是否有这个字符串的字面量<ul>
<li>如果存在，返回引用实例。</li>
<li>不存在，实例化该字符串放入常量池。</li>
</ul>
</li>
</ul>
<p>字符串常量池位置</p>
<ul>
<li><p>JDK&lt;=1.6，有永久代，运行时常量池放在永久代，运行时常量池包含字符串常量池</p>
</li>
<li><p>JDK=1.7，有永久代，但是已经逐步「去永久代」，字符串常量池从运行时常量池分离出来放在堆里。永久代中主要存放的是「类型信息」</p>
</li>
<li><p>JDK&gt;=1.8，取消永久代，由元空间取代，运行时常量池在元空间，字符串常量池在堆里。</p>
</li>
</ul>
<p>代码验证,字符串常量池在堆中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * jdk6：-Xms6M -Xmx6M -XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment">    * jdk8：-Xms6M -Xmx6M -XX:MetaspaceSize=6M -XX:MaxMetaspaceSize=6M</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">           String str = String.valueOf(i).intern();</span><br><span class="line">           list.add(str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280028763.png"></p>
<h3 id="三种字符串操作"><a href="#三种字符串操作" class="headerlink" title="三种字符串操作"></a>三种字符串操作</h3><h4 id="直接赋值-只会在常量池中。"><a href="#直接赋值-只会在常量池中。" class="headerlink" title="直接赋值,只会在常量池中。"></a><strong>直接赋值,只会在常量池中。</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>; <span class="comment">// s指向常量池中的引用</span></span><br></pre></td></tr></table></figure>



<h4 id="new-String"><a href="#new-String" class="headerlink" title="new String();"></a><strong>new String();</strong></h4><p>用new String()创建的字符串不是常量，不能在编译期就确定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>先在常量池中检查是否存在。</p>
<ul>
<li>如果不存在，先在字符串常量池中创建一个字符串对象，再从堆中的非字符串常量池区创建一个字符串对象。一共创建了两个，都在堆中，字符串常量池内、外各有一个。用到的是字符串常量池以外的那个字符串，常量池中的相当于建了个缓存，下次使用的时候会先进常量池中拿。</li>
<li>如果字符串常量池中存在，直接将内存中的引用返回</li>
</ul>
<p><strong>注意：</strong>字符串常量池中创建的”abc”，并不是new String()创建的，而是在代码中写的常量直接创建的。new String()只会在堆中字符串常量池外创建一个对象。</p>
<h4 id="intern"><a href="#intern" class="headerlink" title="intern();"></a><strong>intern();</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = str1.intern();</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>是一个native方法。调用时，判断常量池中是否存在。</p>
<ul>
<li>如果有，返回常量池中的字符串(的引用) – <strong>返回的是 字符串常量池中的字符串的引用</strong></li>
<li>如果没有，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。– <strong>返回的是 字符串对象的引用(与上面对立，不是字符串常量池的引用)</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029008.png"></p>
<h4 id="下面的代码创建了多少个-String-对象-打印结果是什么"><a href="#下面的代码创建了多少个-String-对象-打印结果是什么" class="headerlink" title="下面的代码创建了多少个 String 对象,打印结果是什么"></a>下面的代码创建了多少个 String 对象,打印结果是什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;he&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<p>先说结果，不考虑GC的情况下</p>
<ul>
<li>JDK&gt;=1.7 输出是 true，创建了 5 个对象</li>
<li>JDK&lt;=1.6 输出 false,创建6个对象</li>
</ul>
<p><strong>分析：</strong></p>
<p>JDK&gt;=1.7时，</p>
<p><code>String s1 = new String(&quot;he&quot;) + new String(&quot;llo&quot;);</code>这一行代码，会先在字符串常量池中创建两个字面量 “he”,”llo”，还有堆内字符串常量池外创建两个对象”he”,”llo”，还有最后在堆内字符串常量池外创建的对象”hello”，s1是”hello”的引用。这时候创建了5个对象。</p>
<p><code>String s2 = s1.intern();</code>这行代码，由于字符串常量池中没有”hello”这个字面量，所以会去堆中找”hello”的引用，也就是s1，所以s1==s2为true。</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029798.png"></p>
<p>JDK&lt;=1.6时，第一行代码操作是一样的，只不过字符串常量池是在永久代中。</p>
<p>第二行代码在执行<code>intern()</code>时，如果字符串常量池中没有”hello”，会创建一个”hello”字面量存放在字符串常量池。此时是6个对象。</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029354.png"></p>
<h3 id="几个示例"><a href="#几个示例" class="headerlink" title="几个示例"></a>几个示例</h3><p>示例1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s0=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s1=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;abc&quot;</span> + <span class="string">&quot;de&quot;</span>;</span><br><span class="line">System.out.println( s0==s1 ); <span class="comment">//true</span></span><br><span class="line">System.out.println( s0==s2 ); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>第一行代码，字面量”abcde”存入字符串常量池</li>
<li>第二行代码，直接去字符串常量池中取，所以s0==s1</li>
<li>第三行代码，一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被优化为一个字符串常量”abcde”。之后还是从字符串常量池中取。所以s0==s2</li>
</ul>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;de&quot;</span>);</span><br><span class="line">System.out.println(s0 == s1);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s0 == s2);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li><p>第一行代码，将字面量”abcde”放入字符串常量池，指向s0</p>
</li>
<li><p>第二行代码，用new String() 创建的字符串不是常量，不能在编译期就确定。</p>
<p>创建一个”abcde”的String类型对象到堆里非字符串常量池位置，指向s1</p>
<p>s0和s1是两个对象，所以不相等</p>
</li>
<li><p>第三行代码，将字面量”abc”存入字符串常量池，同样的后半段new String()结果不能在编译期确定，所以new一个String对象”de”，在堆里字符串常量池外，同时也向字符串常量池内存放一份”de”。字面量”abc”和对象”de”相加的结果组成一个新的String对象放在堆内非字符串常量池。所以s0!=s2.</p>
<p>同时，s1和s2是两个String对象,所以s1!=s2</p>
</li>
</ul>
<p>查看字节码可知，第三行代码<code>String s2 = &quot;abc&quot; + new String(&quot;de&quot;);</code>会被优化成<code>StringBuilder.append(&quot;abc&quot;).apend(&quot;de&quot;)</code></p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029799.png"></p>
<p>示例3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String a1 = <span class="string">&quot;a1&quot;</span>;</span><br><span class="line">String b1 = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;</span><br><span class="line">System.out.println(a1 == b1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String a2 = <span class="string">&quot;atrue&quot;</span>;</span><br><span class="line">String b2 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;true&quot;</span>;</span><br><span class="line">System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String a3 = <span class="string">&quot;a3.4&quot;</span>;</span><br><span class="line">String b3 = <span class="string">&quot;a&quot;</span> + <span class="number">3.4</span>;</span><br><span class="line">System.out.println(a3 == b3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解析：JVM对于字符串常量的「+」操作，编译期间会将常量字符串的”+”连接优化为连接后的值。比如<code>&quot;a&quot;+1</code>在编译器优化后生成的class文件中就已经是<code>&quot;a1&quot;</code>了。所以上面的几个结果都为true。</p>
<p>查看JVM指令码：</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029277.png"></p>
<p>示例4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s1 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;a&quot;</span> + s1;</span><br><span class="line">System.out.println(s0 == s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>第一行代码，字面量”ab”放入字符串常量池，s0指向字面量”ab”，s0是字面量的引用</li>
<li>第二行代码，字面量”b”放入字符串常量池,s1指向字面量”b”,s1是字面量”b”的引用</li>
<li>第三行代码，字面量”a”放入字符串常量池，s1是引用，编译期间不能确定。所以最后生成的s2是个String对象放入到堆中非字符串常量池的位置。所以s0!=s2<ul>
<li>编译期间，会把<code>&quot;a&quot; + s1;</code>优化成<code>StringBuilder.append(&quot;a&quot;).append(s1)</code></li>
</ul>
</li>
</ul>
<p>示例5：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;a&quot;</span> + s1;</span><br><span class="line">System.out.println(s0 == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>跟上一个示例相比，第二行代码多了个final，结果就会不同。因为final修饰的变量，在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以<code>&quot;a&quot;+s1</code>和<code>&quot;a&quot;+:&quot;b&quot;</code>效果相同，所以结果为true.</p>
<p>JVM指令码：</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029107.png"></p>
<p>示例6：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s0 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s1 = getB();</span><br><span class="line">    String s2 = <span class="string">&quot;a&quot;</span> + s1;</span><br><span class="line">    System.out.println(s0 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>与上一个示例相比，s1虽然是final修饰，但是调用的方法。</p>
<p>只有在程序运行之后，才能调用getB()方法，将”a”和返回值动态链接并分配地址给s2。</p>
<p>所以s0!=s2</p>
<p>JVM指令码：</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029224.png"></p>
<p>示例7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;  <span class="comment">//就等价于String s = &quot;abc&quot;;</span></span><br><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">String s1 = a + b + c;</span><br><span class="line">System.out.println(s0 == s1); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><code>String s1 = a + b + c;</code>会被优化成<code>StringBuilder.append(a).append(b).append(c).toString()</code>，然后作为一个新的字符串对象保存在堆中非字符串常量池位置。所以s0!=s1</p>
<p>JVM指令码：</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280029246.png"></p>
<p>示例8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">System.out.println(s1 == s1.intern());   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>).toString();</span><br><span class="line">System.out.println(s2 == s2.intern());  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>编译期间，字面量”test”存入字符串常量池。</li>
<li>在堆中非字符串常量池中，new 一个”test”的String对象，s1是这个对象的引用。</li>
<li><code>s1.intern();</code>会先去字符串常量池中找，如果找到就返回。所以s1!=s1.intern()</li>
<li>下面的new StringBuilder()同理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280030808.png"></p>
<p>JVM指令码：</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280030076.png"></p>
<p>示例9：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;技术&quot;</span>).toString();</span><br><span class="line">System.out.println(str1 == str1.intern());  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">System.out.println(str2 == str2.intern());  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>第一行代码，字面量”计算机”和”技术”存入字符串常量池，新的字符串”计算机技术”在堆内非字符串常量池中，str1指向这个对象，是”计算机技术”这个对象的引用</li>
<li>str1.intern()，因为在字符串常量池中不存在”计算机技术”这个字面量，所以会复制一份这个字面量，然后返回str1的引用，所以str1==str1.intern()</li>
<li>下面换成java为什么就不行了呢。因为intern会先去找字符串常量池中是否存在，「java」这个关键字在编译期间肯定已经存入过字符串常量池了，所以str2.intern()返回的是字符串常量池中的引用，所以str2!=str2.intern()</li>
</ul>
<h2 id="八种基础类型的包装类常量池"><a href="#八种基础类型的包装类常量池" class="headerlink" title="八种基础类型的包装类常量池"></a>八种基础类型的包装类常量池</h2><p>Java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫对象池，在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。</p>
<p>另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p>
<p>Integer在初始化时候，会创建[-128,127]的缓存池。如果定义Integer值在范围内，会进缓存池拿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5种整形的包装类Byte,Short,Integer,Long,Character的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在值小于127时可以使用对象池</span></span><br><span class="line">Integer i1 = <span class="number">127</span>;  <span class="comment">// 这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池</span></span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值大于127时，不会从对象池中取对象</span></span><br><span class="line">Integer i3 = <span class="number">128</span>;</span><br><span class="line">Integer i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用new关键词新生成对象不会使用对象池</span></span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i5 == i6);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean类也实现了对象池技术</span></span><br><span class="line">Boolean bool1 = <span class="keyword">true</span>;</span><br><span class="line">Boolean bool2 = <span class="keyword">true</span>;</span><br><span class="line">System.out.println(bool1 == bool2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用new关键词新生成对象不会使用对象池</span></span><br><span class="line">Boolean bool3 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">Boolean bool4 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(bool3 == bool4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点类型的包装类没有实现对象池技术</span></span><br><span class="line">Float f1 = <span class="number">1F</span>;</span><br><span class="line">Float f2 = <span class="number">1F</span>;</span><br><span class="line">System.out.println(f1 == f2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Double d1 = <span class="number">1.0</span>;</span><br><span class="line">Double d2 = <span class="number">1.0</span>;</span><br><span class="line">System.out.println(d1 == d2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p>查看以下代码的JVM指令码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在值小于127时可以使用对象池</span></span><br><span class="line">Integer i1 = <span class="number">127</span>;  <span class="comment">// 这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池</span></span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用new关键词新生成对象不会使用对象池</span></span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i5 == i6);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>查看JVM指令码可知，<code>Integer i1 = 127;</code>赋值使用的是Integer.valueOf()，new的方式调用了<code>&lt;init&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280030631.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/18/JVM/JVM-08-JVM%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/JVM/JVM-08-JVM%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">JVM调优</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-18 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-18T00:00:00+08:00">2022-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:15:21" itemprop="dateModified" datetime="2022-03-27T23:15:21+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前置，启动一个javaweb工程</p>
<h2 id="jps命令"><a href="#jps命令" class="headerlink" title="jps命令"></a>jps命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure>

<p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine<br>Identifier）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\ChangZhen&gt; jps</span><br><span class="line">17120 RemoteMavenServer36</span><br><span class="line">18932</span><br><span class="line">23092 Jps</span><br><span class="line">13868</span><br><span class="line">15964 SpringbootStartDemoApplication</span><br></pre></td></tr></table></figure>

<p>15964即为当前测试工程进程PID</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main() 函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是JAR包，则输出JAR路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时的JVM参数</td>
</tr>
</tbody></table>
<h2 id="jmap命令"><a href="#jmap命令" class="headerlink" title="jmap命令"></a>jmap命令</h2><p>用于生成堆转储快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>

<p>option选项的合法值与具体含义:</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-dump</td>
<td>生成Java堆转储快照。格式为-dump:[live,]format=b,file=<filename>,其中 live 子参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td align="left">-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="left">-heap</td>
<td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="left">-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td align="left">-permstat</td>
<td>以 ClassLoader 为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td align="left">-F</td>
<td>当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照。只在Linux/Solaris平台下有效</td>
</tr>
</tbody></table>
<h3 id="jmap-histo-堆中对象统计信息，实例个数以及占用内存大小"><a href="#jmap-histo-堆中对象统计信息，实例个数以及占用内存大小" class="headerlink" title="jmap -histo 堆中对象统计信息，实例个数以及占用内存大小"></a><code>jmap -histo</code> 堆中对象统计信息，实例个数以及占用内存大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo pid &gt; 输出文件.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        144255       47998792  [B</span><br><span class="line">   2:        255631       31344784  [C</span><br><span class="line">   3:         19245       19140848  [I</span><br><span class="line">   4:        129191        3100584  java.lang.String</span><br><span class="line">   5:         26126        1610472  [Ljava.lang.Object;</span><br><span class="line">   6:         62081        1309792  [Ljava.lang.Class;</span><br><span class="line">   7:         12850        1130800  java.lang.reflect.Method</span><br><span class="line">   8:          6495         718512  java.lang.Class</span><br><span class="line">   9:          8666         677168  [S</span><br><span class="line">  10:         12090         677040  jdk.internal.org.objectweb.asm.Item</span><br><span class="line">  11:          7735         636848  [Ljava.util.HashMap$Node;</span><br><span class="line">  12:         25718         617232  java.lang.StringBuilder</span><br><span class="line">  13:         17840         570880  java.util.HashMap$Node</span><br><span class="line">  14:         14941         478112  java.util.ArrayList$Itr</span><br><span class="line">  15:         14548         465536  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">  16:         11549         461960  java.util.LinkedHashMap$Entry</span><br><span class="line">  17:           393         371280  [Ljdk.internal.org.objectweb.asm.Item;</span><br><span class="line">  18:          6066         367920  [Ljava.lang.String;</span><br><span class="line">  19:          6645         318960  java.util.HashMap</span><br><span class="line">  20:          5522         309232  java.util.LinkedHashMap</span><br><span class="line">  21:          4734         302976  java.net.URL</span><br><span class="line">  22:          5503         229104  [Ljava.lang.reflect.Method;</span><br><span class="line">  23:          8448         202752  java.util.ArrayList</span><br><span class="line">  24:           905         202720  jdk.internal.org.objectweb.asm.MethodWriter</span><br><span class="line">  25:           144         199296  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class="line">  26:          5521         176672  java.util.LinkedHashMap$LinkedKeyIterator</span><br><span class="line">  27:          2192         175360  java.lang.reflect.Constructor</span><br><span class="line">  28:          2421         174312  java.lang.reflect.Field</span><br><span class="line">  29:          3585         172080  org.springframework.core.ResolvableType</span><br><span class="line">  30:          3686         147440  java.lang.invoke.MethodType</span><br><span class="line">  31:          8797         140752  java.lang.Object</span><br><span class="line">  32:          5841         140184  sun.misc.ProxyGenerator$ConstantPool$IndirectEntry</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">3558:             1             16  sun.util.calendar.Gregorian</span><br><span class="line">3559:             1             16  sun.util.locale.provider.AuxLocaleProviderAdapter$NullProvider</span><br><span class="line">3560:             1             16  sun.util.locale.provider.CalendarDataUtility$CalendarWeekParameterGetter</span><br><span class="line">3561:             1             16  sun.util.locale.provider.SPILocaleProviderAdapter</span><br><span class="line">3562:             1             16  sun.util.locale.provider.TimeZoneNameUtility$TimeZoneNameGetter</span><br><span class="line">3563:             1             16  sun.util.resources.LocaleData</span><br><span class="line">3564:             1             16  sun.util.resources.LocaleData$LocaleDataResourceBundleControl</span><br><span class="line">Total       1063078      121667984</span><br></pre></td></tr></table></figure>



<p>输出的文件展示的是类的列表</p>
<table>
<thead>
<tr>
<th>num</th>
<th>#instances</th>
<th>#bytes</th>
<th>class name</th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>类的实例数量</td>
<td>实例占用的内存</td>
<td>类名</td>
</tr>
</tbody></table>
<p>类名的一些简写：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>[C</td>
<td>char[]</td>
</tr>
<tr>
<td>[S</td>
<td>short[]</td>
</tr>
<tr>
<td>[I</td>
<td>int[]</td>
</tr>
<tr>
<td>[B</td>
<td>byte[]</td>
</tr>
<tr>
<td>[[I</td>
<td>int</td>
</tr>
</tbody></table>
<h3 id="堆信息-jmap-heap"><a href="#堆信息-jmap-heap" class="headerlink" title="堆信息 jmap -heap"></a>堆信息 <code>jmap -heap</code></h3><p>Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 15964, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.181-b13</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 13 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 8577351680 (8180.0MB)</span><br><span class="line">   NewSize                  = 178782208 (170.5MB)</span><br><span class="line">   MaxNewSize               = 2858942464 (2726.5MB)</span><br><span class="line">   OldSize                  = 358088704 (341.5MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 134742016 (128.5MB)</span><br><span class="line">   used     = 121697088 (116.05938720703125MB)</span><br><span class="line">   free     = 13044928 (12.44061279296875MB)</span><br><span class="line">   90.31858926617218% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 22020096 (21.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 22020096 (21.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 191889408 (183.0MB)</span><br><span class="line">   used     = 7516472 (7.168266296386719MB)</span><br><span class="line">   free     = 184372936 (175.83173370361328MB)</span><br><span class="line">   3.917085407861595% used</span><br><span class="line"></span><br><span class="line">13817 interned Strings occupying 1206464 bytes.</span><br></pre></td></tr></table></figure>

<p>输出的信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 堆的配置信息</span></span><br><span class="line">    <span class="attr">&quot;Heap Configuration&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;MinHeapFreeRatio&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MaxHeapFreeRatio&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MaxHeapSize&quot;</span>:<span class="string">&quot;最大堆内存&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;NewSize&quot;</span>:<span class="string">&quot;新生代空间&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MaxNewSize&quot;</span>:<span class="string">&quot;新生代最大的容量&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;OldSize&quot;</span>:<span class="string">&quot;老年代空间&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;NewRatio&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;SurvivorRatio&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MetaspaceSize&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;CompressedClassSpaceSize&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;MaxMetaspaceSize&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;G1HeapRegionSize&quot;</span>:<span class="string">&quot;</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">    // 堆使用情况</span></span><br><span class="line"><span class="string">    &quot;</span>Heap Usage<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">        &quot;</span>PS Young Generation<span class="string">&quot;:   // 新生代</span></span><br><span class="line"><span class="string">        &#123;       </span></span><br><span class="line"><span class="string">          &quot;</span>Eden Space<span class="string">&quot;: // Eden区</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              &quot;</span>capacity<span class="string">&quot;: &quot;</span>现有容量<span class="string">&quot;</span></span><br><span class="line"><span class="string">              &quot;</span>used<span class="string">&quot;: &quot;</span>使用容量<span class="string">&quot;</span></span><br><span class="line"><span class="string">              &quot;</span>free<span class="string">&quot;: &quot;</span>空闲多少<span class="string">&quot;</span></span><br><span class="line"><span class="string">              &quot;</span><span class="number">90.31858926617218</span>% used<span class="string">&quot;: &quot;</span>使用百分比<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &quot;</span>From Space<span class="string">&quot;: // From Survivor</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              &quot;</span>capacity<span class="string">&quot;: 22020096 (21.0MB)</span></span><br><span class="line"><span class="string">              &quot;</span>used<span class="string">&quot;:                       0 (0.0MB)</span></span><br><span class="line"><span class="string">              &quot;</span>free<span class="string">&quot;: 22020096 (21.0MB)</span></span><br><span class="line"><span class="string">              0.0% used</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">          &quot;</span>To Space<span class="string">&quot;:  // To Survivor</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              &quot;</span>capacity<span class="string">&quot;: 22020096 (21.0MB)</span></span><br><span class="line"><span class="string">              &quot;</span>used<span class="string">&quot;:                       0 (0.0MB)</span></span><br><span class="line"><span class="string">              &quot;</span>free<span class="string">&quot;: 22020096 (21.0MB)</span></span><br><span class="line"><span class="string">              0.0% used</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &quot;</span>PS Old Generation<span class="string">&quot;: // 老年代</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;</span>capacity<span class="string">&quot;: 191889408 (183.0MB)</span></span><br><span class="line"><span class="string">          &quot;</span>used<span class="string">&quot;: 7516472 (7.168266296386719MB)</span></span><br><span class="line"><span class="string">          &quot;</span>free<span class="string">&quot;: 184372936 (175.83173370361328MB)</span></span><br><span class="line"><span class="string">          3.917085407861595% used</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="jmap-dump-生成Java堆转储快照"><a href="#jmap-dump-生成Java堆转储快照" class="headerlink" title="jmap -dump 生成Java堆转储快照"></a><code>jmap -dump</code> 生成Java堆转储快照</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=输出文件名.hprof pid</span><br></pre></td></tr></table></figure>

<p>生成<code>.hprof</code>文件,通过可视化程序打开,比如Java VisualVM(<code>jvisualvm</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure>

<p><img src="http://image.changzhen0212.cn/img/202201161644102.png"></p>
<p>选择刚才到导出的.hprof文件。</p>
<p>显示的是导出文件的那一刻的堆使用信息。和<code>jmap -histo</code>打印的信息差不多。</p>
<p><img src="http://image.changzhen0212.cn/img/202201161647792.png"></p>
<p>可以设置参数，OOM时自动生成堆dump快照。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-XX</span>:<span class="string">+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">HeapDumpPath=./ #（路径）</span></span><br></pre></td></tr></table></figure>

<h3 id="OOMdemo"><a href="#OOMdemo" class="headerlink" title="OOMdemo"></a>OOMdemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ChangZhen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM设置</span></span><br><span class="line">    <span class="comment">// -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> User(i++, UUID.randomUUID().toString()));</span><br><span class="line">            <span class="keyword">new</span> User(j--, UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OOM时生成堆dump快照，装入jvisualvm</p>
<p><img src="http://image.changzhen0212.cn/img/202201171111128.png"></p>
<h2 id="jstack命令"><a href="#jstack命令" class="headerlink" title="jstack命令"></a>jstack命令</h2><p>用于生成虚拟机当前时刻的线程快照。</p>
<p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure>

<p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody></table>
<p>输入<code>jstack -l 15964</code>查看线程堆栈（部分结果）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2022-01-16 20:59:28</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.181-b13 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;RMI Scheduler(0)&quot; #38 daemon prio=5 os_prio=0 tid=0x00000000286ae800 nid=0x272c waiting on condition [0x000000002becf000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait for  &lt;0x00000005c1187828&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1081)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>



<p>打印结果的参数说明：</p>
<table>
<thead>
<tr>
<th>打印结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RMI Scheduler(0)</td>
<td>线程名称</td>
</tr>
<tr>
<td>prio=5</td>
<td>java线程，优先级=5</td>
</tr>
<tr>
<td>os_prio=0</td>
<td>系统线程，优先级=0</td>
</tr>
<tr>
<td>tid=0x00000000286ae800</td>
<td>线程ID</td>
</tr>
<tr>
<td>nid=0x272c</td>
<td>线程对应的本地内核线程标识nid</td>
</tr>
<tr>
<td>waiting on condition [0x000000002becf000] java.lang.Thread.State: WAITING (parking)</td>
<td>线程状态</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="死锁Demo"><a href="#死锁Demo" class="headerlink" title="死锁Demo"></a>死锁Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 begin&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 end&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 begin&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 end&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>jps -l</code>查看pid</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">6068 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">4664</span><br><span class="line">984 sun.tools.jps.Jps</span><br><span class="line">13580</span><br><span class="line">16076 com.cz.springbootstartdemo.test.DeadLockTest</span><br></pre></td></tr></table></figure>

<p><code>jstack -l 16076</code> 跟到最后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ca2e8 (object 0x000000076b1a9290, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ca4f8 (object 0x000000076b1a92a0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">        at com.cz.springbootstartdemo.test.DeadLockTest.lambda$main$1(DeadLockTest.java:33)</span><br><span class="line">        - waiting to lock &lt;0x000000076b1a9290&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b1a92a0&gt; (a java.lang.Object)</span><br><span class="line">        at com.cz.springbootstartdemo.test.DeadLockTest$$Lambda$2/2121055098.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">        at com.cz.springbootstartdemo.test.DeadLockTest.lambda$main$0(DeadLockTest.java:20)</span><br><span class="line">        - waiting to lock &lt;0x000000076b1a92a0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b1a9290&gt; (a java.lang.Object)</span><br><span class="line">        at com.cz.springbootstartdemo.test.DeadLockTest$$Lambda$1/1225358173.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h3 id="jvisualvm-自动检测死锁"><a href="#jvisualvm-自动检测死锁" class="headerlink" title="jvisualvm 自动检测死锁"></a>jvisualvm 自动检测死锁</h3><p><img src="http://image.changzhen0212.cn/img/202201171118280.png"></p>
<h3 id="jstack找出占用cpu最高的线程堆栈信息"><a href="#jstack找出占用cpu最高的线程堆栈信息" class="headerlink" title="jstack找出占用cpu最高的线程堆栈信息"></a>jstack找出占用cpu最高的线程堆栈信息</h3><ol>
<li>使用命令<code>top -p &lt;pid&gt;</code>，显示进程的内存情况，pid是java进程号，比如19663</li>
<li>按H，获取每个线程的内存情况 </li>
<li>找到内存和cpu占用最高的线程tid，比如19664</li>
<li>转为十六进制得到 0x4cd0，此为线程id的十六进制表示</li>
<li>执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法</li>
<li>查看对应的堆栈信息找出可能存在问题的代码</li>
</ol>
<h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p>实时查看和调整虚拟机各项扩展参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option ] pid</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-flag</td>
<td>未被显式指定的参数的系统默认值</td>
</tr>
<tr>
<td>-sysprops</td>
<td>打印虚拟机进程的System.getProperties()的内容</td>
</tr>
</tbody></table>
<h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><p>监视虚拟机各种运行状态信息的命令行工具。</p>
<p>可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</p>
<p>jstat命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat [ option vmid [interval[s|ms] [count]] ]</span><br><span class="line">jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数]</span><br></pre></td></tr></table></figure>

<p>选项说明</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与一gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代垃圾收集状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与 -gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代垃圾收集状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出即时编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出已经被即时编译的方法</td>
</tr>
</tbody></table>
<h3 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h3><p><strong>jstat -gc pid 最常用</strong>，可以评估程序内存使用及GC压力整体情况</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>第一个幸存区的大小，单位KB</td>
</tr>
<tr>
<td>S1C</td>
<td>第二个幸存区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>第一个幸存区的使用大小</td>
</tr>
<tr>
<td>S1U</td>
<td>第二个幸存区的使用大小</td>
</tr>
<tr>
<td>EC</td>
<td>伊甸园区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>伊甸园区的使用大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用大小</td>
</tr>
<tr>
<td>MC</td>
<td>方法区大小(元空间)</td>
</tr>
<tr>
<td>MU</td>
<td>方法区使用大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间，单位s</td>
</tr>
</tbody></table>
<h3 id="堆内存统计"><a href="#堆内存统计" class="headerlink" title="堆内存统计"></a>堆内存统计</h3><p><strong>jstat -gccapacity pid</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>新生代最小容量</td>
</tr>
<tr>
<td>NGCMX</td>
<td>新生代最大容量</td>
</tr>
<tr>
<td>NGC</td>
<td>当前新生代容量</td>
</tr>
<tr>
<td>S0C</td>
<td>第一个幸存区大小</td>
</tr>
<tr>
<td>S1C</td>
<td>第二个幸存区的大小</td>
</tr>
<tr>
<td>EC</td>
<td>伊甸园区的大小</td>
</tr>
<tr>
<td>OGCMN</td>
<td>老年代最小容量</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大容量</td>
</tr>
<tr>
<td>OGC</td>
<td>当前老年代大小</td>
</tr>
<tr>
<td>OC</td>
<td>当前老年代大小</td>
</tr>
<tr>
<td>MCMN</td>
<td>最小元数据容量</td>
</tr>
<tr>
<td>MCMX</td>
<td>最大元数据容量</td>
</tr>
<tr>
<td>MC</td>
<td>当前元数据空间大小</td>
</tr>
<tr>
<td>CCSMN</td>
<td>最小压缩类空间大小</td>
</tr>
<tr>
<td>CCSMX</td>
<td>最大压缩类空间大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>当前压缩类空间大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代GC次数</td>
</tr>
</tbody></table>
<h3 id="新生代垃圾回收统计"><a href="#新生代垃圾回收统计" class="headerlink" title="新生代垃圾回收统计"></a>新生代垃圾回收统计</h3><p><strong>jstat -gcnew pid</strong><br>|参数|说明|<br>|—-|—-|<br>|S0C|第一个幸存区的大小|<br>|S1C|第二个幸存区的大小|<br>|S0U|第一个幸存区的使用大小|<br>|S1U|第二个幸存区的使用大小|<br>|TT|对象在新生代存活的次数|<br>|MTT|对象在新生代存活的最大次数|<br>|DSS|期望的幸存区大小|<br>|EC|伊甸园区的大小|<br>|EU|伊甸园区的使用大小|<br>|YGC|年轻代垃圾回收次数|<br>|YGCT|年轻代垃圾回收消耗时间|</p>
<h3 id="老年代垃圾回收统计"><a href="#老年代垃圾回收统计" class="headerlink" title="老年代垃圾回收统计"></a>老年代垃圾回收统计</h3><p><strong>jstat -gcold pid</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MC</td>
<td>方法区大小</td>
</tr>
<tr>
<td>MU</td>
<td>方法区使用大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间使用大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间</td>
</tr>
</tbody></table>
<h3 id="老年代内存统计"><a href="#老年代内存统计" class="headerlink" title="老年代内存统计"></a>老年代内存统计</h3><p><strong>jstat -gcoldcapacity pid</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OGCMN</td>
<td>老年代最小容量</td>
</tr>
<tr>
<td>OGCMX</td>
<td>老年代最大容量</td>
</tr>
<tr>
<td>OGC</td>
<td>当前老年代大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间</td>
</tr>
</tbody></table>
<h3 id="元数据空间统计"><a href="#元数据空间统计" class="headerlink" title="元数据空间统计"></a>元数据空间统计</h3><p><strong>jstat -gcmetacapacity pid</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MCMN</td>
<td>最小元数据容量</td>
</tr>
<tr>
<td>MCMX</td>
<td>最大元数据容量</td>
</tr>
<tr>
<td>MC</td>
<td>当前元数据空间大小</td>
</tr>
<tr>
<td>CCSMN</td>
<td>最小压缩类空间大小</td>
</tr>
<tr>
<td>CCSMX</td>
<td>最大压缩类空间大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>当前压缩类空间大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间</td>
</tr>
</tbody></table>
<p><strong>jstat -gcutil pid</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>S0</td>
<td>幸存1区当前使用比例</td>
</tr>
<tr>
<td>S1</td>
<td>幸存2区当前使用比例</td>
</tr>
<tr>
<td>E</td>
<td>伊甸园区使用比例</td>
</tr>
<tr>
<td>O</td>
<td>老年代使用比例</td>
</tr>
<tr>
<td>M</td>
<td>元数据区使用比例</td>
</tr>
<tr>
<td>CCS</td>
<td>压缩使用比例</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间</td>
</tr>
</tbody></table>
<h2 id="调优的思路"><a href="#调优的思路" class="headerlink" title="调优的思路"></a>调优的思路</h2><p>目的：</p>
<ul>
<li>主要是优化GC，主要是优化Full GC</li>
<li>尽量每次Young GC后的存活对象小于Survivor区的50%，都留在新生代里。</li>
<li>尽量不让对象进入老年代</li>
<li>尽量减少Full GC，避免频繁Full GC对性能的影响</li>
</ul>
<p>方法：</p>
<p>根据<code>jstat gc -pid</code>获取的信息，和JVM参数的配置，计算出对象在不同分代空间的流转流程FullGC和YoungGC触发的次数和耗时，计算出每天、每小时的GC次数，再计算出每次GC的耗时。</p>
<ol>
<li><p>计算新生代对象增长的速率</p>
<p>根据YoungGC的次数和Eden区的大小，可以计算出每分钟、每秒中产生的对象大小。</p>
</li>
<li><p>Young GC的触发频率和每次耗时</p>
</li>
<li><p>YoungGC每次有多少进入老年代</p>
</li>
<li><p>Full GC的触发频率和每次耗时</p>
</li>
<li><p><strong>优化思路</strong>其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响</p>
</li>
</ol>
<h2 id="调优案例"><a href="#调优案例" class="headerlink" title="调优案例"></a>调优案例</h2><p>模拟场景：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>机器配置</td>
<td>2核4G</td>
</tr>
<tr>
<td>JVM内存大小</td>
<td>2G</td>
</tr>
<tr>
<td>系统运行时间</td>
<td>7天</td>
</tr>
<tr>
<td>期间发生的Full GC次数和耗时</td>
<td>500多次，200多秒</td>
</tr>
<tr>
<td>期间发生的Young GC次数和耗时</td>
<td>1万多次，500多秒</td>
</tr>
</tbody></table>
<p>JVM参数：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xms1536M</span> <span class="string">#堆</span></span><br><span class="line"><span class="attr">-Xmx1536M</span></span><br><span class="line"><span class="meta">-Xmn512M</span> <span class="string"># 新生代</span></span><br><span class="line"><span class="meta">-Xss256K</span> <span class="string"># 栈</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">SurvivorRatio=6 # Eden与Survivor区的比例为6:1</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MetaspaceSize=256M #元空间初始值</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxMetaspaceSize=256M #元空间最大值</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseParNewGC # 新生代使用ParNew</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseConcMarkSweepGC # 老年代使用CMS</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">CMSInitiatingOccupancyFraction=75 # cms超过75%触发老年代GC</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">+UseCMSInitiatingOccupancyOnly # 只使用设定的回收阈值</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/process&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processUserData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = queryUsers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user: users) &#123;</span><br><span class="line">            <span class="comment">//TODO 业务处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;user:&quot;</span> + user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟批量查询用户场景</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;User&gt; <span class="title">queryUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            users.add(<span class="keyword">new</span> User(i,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：每秒调用一次查询用户接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes=&#123;SpringbootStartDemoApplication.class&#125;)</span><span class="comment">// 指定启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">         String result = restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/jvmdemo/user/process&quot;</span>, String.class);</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>场景分析：</p>
<p>堆内存为1536M，新生代512M，则老年代为1536-512=1024M=1G，新生代中配置了参数<code>-XX:SurvivorRatio=6</code>所以Eden:S0:S1=6:1:1，Eden=384M,S0=S1=64M。方法去256M，栈256K。得出下图</p>
<p><img src="http://image.changzhen0212.cn/img/202201171412712.png"></p>
<p>分析Full GC,7天，500多次，200多秒，平均到每天是70多次，28秒多，再平均到每小时，每小时3次。</p>
<p>分析Young GC，7天，1万多次，500多秒，平均到每天是1428次，平均到每小时，59次，差不多每分钟都会进行一次Young GC</p>
<p>1G的老年代，每20分钟就有700多M的对象挪到老年代，这是不正常的。老年代存放的都是一些老顽固对象，不应该有周期性的频繁变动，此时应该扩大新生代。</p>
<p>考虑对象进入老年代的条件，其中有<strong>对象动态年龄判断</strong>，<strong>老年代空间分配担保机制</strong>思考是否符合这两种场景。</p>
<p>通常触发老年代空间分配担保机制是因为老年代比较小。</p>
<p>为了更快看到效果，2秒一次Full GC，2次Young GC。</p>
<p><code>jstat -gc pid 轮询时间 查看次数</code> 打印变化</p>
<p><img src="http://image.changzhen0212.cn/img/202201171504659.png"></p>
<p>jinfo -flags查看参数是否生效</p>
<p><img src="http://image.changzhen0212.cn/img/202201171510012.png"></p>
<p>先调cms,<code>-XX:CMSInitiatingOccupancyFraction</code>: 当老年代使用达到该比例时会触发FullGC</p>
<p>cms触发GC比例调整到92</p>
<p><img src="http://image.changzhen0212.cn/img/202201171516863.png"></p>
<p>发现并没有生效，Full GC依然很频繁</p>
<p>适当调新生代</p>
<p>新生代适当调整Eden区和Survivor区比例 8:1:1</p>
<p><img src="http://image.changzhen0212.cn/img/202201171533812.png"></p>
<p>Full GC依旧频繁</p>
<p>调整新生代和老年代的大小 新生代调整为1G</p>
<p><img src="http://image.changzhen0212.cn/img/202201171538547.png"></p>
<p>Full GC 更频繁了 由之前的2秒1次变为2秒2次。</p>
<p>老年代比新生代触发得还多的原因</p>
<ol>
<li>老年代空间担保机制，可能在minor gc之前做一次full gc, 再次minor gc,老年代满了，又触发一次Full GC</li>
<li>元空间不够</li>
<li>显示调用System.gc()造成多余的full gc</li>
</ol>
<p>考虑到可能是因为老年代空间分配担保机制，当新生代对象的大小超出老年代，会先做一次full GC，在做minor gc, minor gc后老年代又达到了95%，又一次full gc，看是否能从代码着手优化</p>
<p>代码中每次要构建出5000个User对象，可能是User对象太大，减少每次构建的User对象，改为500次。</p>
<p><img src="http://image.changzhen0212.cn/img/202201171546701.png"></p>
<p>不再有Full GC 问题解决</p>
<h2 id="阿里巴巴Arhtas调优工具"><a href="#阿里巴巴Arhtas调优工具" class="headerlink" title="阿里巴巴Arhtas调优工具"></a>阿里巴巴Arhtas调优工具</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>下载后执行jar包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>选择要查看的java进程</p>
<p><img src="http://image.changzhen0212.cn/img/202201181148183.png"></p>
<p>启动成功。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>输入<code>dashboard</code>可以查看整个进程的运行情况，线程、内存、GC、运行环境信息</p>
<p><img src="http://image.changzhen0212.cn/img/202201181544835.png"></p>
</li>
<li><p>输入<code>thread</code>可以查看线程详细情况</p>
</li>
<li><p>输入 <code>thread加上线程ID</code> 可以查看线程堆栈</p>
</li>
<li><p>输入 <code>thread -b</code> 可以查看线程死锁</p>
</li>
<li><p>输入 <code>jad加类的全名</code> 可以反编译，这样可以方便我们查看线上代码是否是正确的版本</p>
</li>
<li><p>使用 <code>ognl</code> 命令可以查看线上系统变量的值，甚至可以修改变量的值</p>
</li>
</ul>
<h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>打印GC日志到文件。</p>
<p>jar包启动方式</p>
<p>tomcat加在JAVA_OPTS变量中</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-jar -Xloggc:./gc-%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M jar包名称.jar</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xloggc:./gc-%t.log</td>
<td><code>./</code>当前路径，打印GC日志的文件名,%t代表时间</td>
</tr>
<tr>
<td>-XX:GCLogFileSize=100M</td>
<td>文件大小100M</td>
</tr>
</tbody></table>
<p>部分打印结果</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2022-01-18T06</span>:<span class="string">32:03.368+0800: 1.088: [GC (Allocation Failure) [PSYoungGen: 131584K-&gt;5853K(153088K)] 131584K-&gt;5869K(502784K), 0.0076071 secs] [Times: user=0.20 sys=0.00, real=0.01 secs]</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">时间点</span>: <span class="string">[GC类型Minor GC(GC原因 分配空间失败)，[新生代GC前大小-&gt;GC后大小(新生代总大小)] 堆GC前大小-&gt;堆GC后大小(堆总大小), 垃圾收集时间]</span></span><br></pre></td></tr></table></figure>



<p>打印结果：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2022-01-18T06</span>:<span class="string">32:05.646+0800: 3.366: [Full GC (Metadata GC Threshold) [PSYoungGen: 7359K-&gt;0K(153088K)] [ParOldGen: 104K-&gt;7213K(179200K)] 7463K-&gt;7213K(332288K), [Metaspace: 20507K-&gt;20507K(1067008K)], 0.0188204 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>Full GC (Metadata GC Threshold)：Full GC 元空间不够</li>
<li>[PSYoungGen: 7359K-&gt;0K(153088K)]：新生代回收</li>
<li>[ParOldGen: 104K-&gt;7213K(179200K)]：老年代回收</li>
<li>7463K-&gt;7213K(332288K)：整堆回收</li>
<li>[Metaspace: 20507K-&gt;20507K(1067008K)], 0.0188204 secs]：元空间回收</li>
</ul>
<p><strong>验证了元空间默认21兆大小，元空间机会不会回收，启动时设置元空间大小</strong></p>
<p>CMS</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xloggc</span>:<span class="string">d:/gc-cms-%t.log -Xms50M -Xmx50M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>部分日志：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.043+0800: 4.816: [GC (Allocation Failure) 2022-01-18T09:41:14.043+0800: 4.816: [ParNew: 15360K-&gt;1663K(15360K), 0.0031942 secs] 28392K-&gt;16815K(49536K), 0.0032554 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.065+0800: 4.839: [GC (GCLocker Initiated GC) 2022-01-18T09:41:14.065+0800: 4.839: [ParNew: 15351K-&gt;1663K(15360K), 0.0032973 secs] 30566K-&gt;18830K(49536K), 0.0033600 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.070+0800: 4.843: [GC (CMS Initial Mark) [1 CMS-initial-mark: 17166K(34176K)] 18871K(49536K), 0.0004183 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.070+0800: 4.843: [CMS-concurrent-mark-start]</span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.079+0800: 4.852: [CMS-concurrent-mark: 0.009/0.009 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.079+0800: 4.852: [CMS-concurrent-preclean-start]</span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.079+0800: 4.853: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="meta">2022-01-18T09</span>:<span class="string">41:14.080+0800: 4.853: [CMS-concurrent-abortable-preclean-start]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>GC (Allocation Failure): 分配失败，开始GC</li>
<li>[ParNew: 15360K-&gt;1663K(15360K), 0.0031942 secs]<ul>
<li>ParNew: 使用ParNew收集器</li>
<li>15360K-&gt;1663K(15360K)：GC前新生代使用15360K，GC后为1663K，新生代总大小15360K</li>
<li>0.0032973 secs： GC时间</li>
<li>30566K-&gt;18830K(49536K)：GC前堆使用30566K，GC后为18830K，堆总大小49536K</li>
</ul>
</li>
<li>[GC (CMS Initial Mark) [1 CMS-initial-mark: 17166K(34176K)] 18871K(49536K), 0.0004183 secs]<ul>
<li>[GC (CMS Initial Mark)：CMS初始标记</li>
</ul>
</li>
<li>[CMS-concurrent-mark-start]：CMS并发标记开始</li>
<li>[CMS-concurrent-preclean-start]：CMS并发清理开始</li>
</ul>
<p>G1</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Xloggc</span>:<span class="string">d:/gc-g1-%t.log -Xms50M -Xmx50M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCCause -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -XX:+UseG1GC </span></span><br></pre></td></tr></table></figure>

<p>部分日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[Parallel Time: 18.1 ms, GC Workers: 4]</span><br><span class="line">      [GC Worker Start (ms): Min: 8191.3, Avg: 8191.3, Max: 8191.3, Diff: 0.0]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.4, Diff: 0.1, Sum: 1.3]</span><br><span class="line">      [Update RS (ms): Min: 0.8, Avg: 0.9, Max: 1.0, Diff: 0.2, Sum: 3.5]</span><br><span class="line">         [Processed Buffers: Min: 4, Avg: 7.5, Max: 10, Diff: 6, Sum: 30]</span><br><span class="line">      [Scan RS (ms): Min: 0.7, Avg: 0.8, Max: 0.8, Diff: 0.1, Sum: 3.2]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 15.9, Avg: 16.0, Max: 16.2, Diff: 0.4, Sum: 64.2]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [GC Worker Total (ms): Min: 18.0, Avg: 18.0, Max: 18.1, Diff: 0.0, Sum: 72.2]</span><br><span class="line">      [GC Worker End (ms): Min: 8209.4, Avg: 8209.4, Max: 8209.4, Diff: 0.0]</span><br><span class="line">   [Code Root Fixup: 0.0 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.0 ms]</span><br><span class="line">   [Other: 1.8 ms]</span><br><span class="line">      [Evacuation Failure: 1.5 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 0.2 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.1 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.0 ms]</span><br><span class="line">   [Eden: 0.0B(1024.0K)-&gt;0.0B(2048.0K) Survivors: 1024.0K-&gt;0.0B Heap: 49.9M(50.0M)-&gt;49.9M(50.0M)]</span><br><span class="line">2022-01-18T10:01:34.237+0800: 8.213: [Full GC (Allocation Failure)  49M-&gt;32M(50M), 0.0645146 secs]</span><br></pre></td></tr></table></figure>





<p>分析GC日志:<a target="_blank" rel="noopener" href="https://gceasy.io/">gceasy.io</a></p>
<p>分析刚才生成的CMS日志</p>
<p><img src="http://image.changzhen0212.cn/img/202201181013437.png"></p>
<p><img src="http://image.changzhen0212.cn/img/202201181013294.png"></p>
<p><img src="http://image.changzhen0212.cn/img/202201181013878.png"></p>
<p>G1生成的日志</p>
<p><img src="http://image.changzhen0212.cn/img/202201181015146.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/16/JVM/JVM-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BZGC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/16/JVM/JVM-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BZGC/" class="post-title-link" itemprop="url">ZGC收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-16T00:00:00+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:14:47" itemprop="dateModified" datetime="2022-03-27T23:14:47+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<h3 id="ZGC内存布局"><a href="#ZGC内存布局" class="headerlink" title="ZGC内存布局"></a>ZGC内存布局</h3><p>ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小。</p>
<p>ZGC的Region可以具有大、中、小三类容量。</p>
<ul>
<li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作「大型Region」，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段）的，因为复制一个大对象的代价非常高昂。</li>
</ul>
<p><img src="http://image.changzhen0212.cn/img/202201151648941.png"></p>
<h3 id="ZGC并发-整理算法的实现"><a href="#ZGC并发-整理算法的实现" class="headerlink" title="ZGC并发-整理算法的实现"></a>ZGC并发-整理算法的实现</h3><p>ZGC收集器采用了<strong>染色指针</strong>技术。染色指针是一种直接<strong>将少量额外的信息存储在指针上</strong>的技术。</p>
<h4 id="硬件和操作系统小知识"><a href="#硬件和操作系统小知识" class="headerlink" title="硬件和操作系统小知识"></a>硬件和操作系统小知识</h4><p>在64位系统中，理论可以访问的内存高达<code>2的64次幂</code>字节，实际上，在AMD64架构中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。操作系统也会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统只支持44位（16TB）的物理地址空间。</p>
<h4 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h4><p>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用；</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过过finalize()才能访问；</li>
<li>1位：Remapped标识，设置此位的值后，对象未指向relocation set中（relocation set表示需要GC的Region集合）；</li>
<li>1位：Marked1标识；</li>
<li>1位：Marked0标识，和上面的Marked1都是标记对象用于辅助GC；</li>
<li>42位：对象的地址（所以它可以支持2^42=4T内存）<br><img src="http://image.changzhen0212.cn/img/202201151724831.png"></li>
</ul>
<h4 id="为什么有2个mark标记？"><a href="#为什么有2个mark标记？" class="headerlink" title="为什么有2个mark标记？"></a>为什么有2个mark标记？</h4><p>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。</p>
<ul>
<li>GC周期1：使用mark0, 则周期结束所有引用mark标记都会成为01。</li>
<li>GC周期2：使用mark1, 则周期的mark标记10，所有引用都能被重新标记。</li>
</ul>
<p>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC<strong>无法支持32位操作系统</strong>，<strong>无法支持压缩指针</strong>（CompressedOops，压缩指针也是32位）。</p>
<h4 id="染色指针的三大优势："><a href="#染色指针的三大优势：" class="headerlink" title="染色指针的三大优势："></a>染色指针的三大优势：</h4><ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<h3 id="ZGC的运作过程"><a href="#ZGC的运作过程" class="headerlink" title="ZGC的运作过程"></a>ZGC的运作过程</h3><p><img src="http://image.changzhen0212.cn/img/202201161155666.png"></p>
<p>分为四个大的阶段。四个阶段都是并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段</p>
<ul>
<li><p><strong>并发标记（Concurrent Mark）</strong>：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记(<strong>Mark Start</strong>)和最终标记(<strong>Mark End</strong>)也会STW，与G1不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新<strong>染色指针</strong>中的Marked 0、 Marked 1标志位。</p>
</li>
<li><p><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成<strong>重分配集（Relocation Set）</strong>。ZGC每次回收都会扫描所有的Region，标记过程是针对全堆的，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</p>
</li>
<li><p><strong>并发重分配（Concurrent Relocate）</strong>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。</p>
<ul>
<li>ZGC指针的<strong>「自愈」（Self-Healing）</strong>：ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中。如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(<strong>读屏障</strong>)所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。</li>
<li>只有第一次访问旧对象会陷入转发，也就是只慢一次。由于染色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于新对象的分配（但是转发表还得留着不能释放掉，因为可能还有访问在使用这个转发表），哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用，它们都可以自愈。</li>
</ul>
</li>
<li><p><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在「自愈」功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</p>
</li>
</ul>
<h3 id="ZGC存在的问题"><a href="#ZGC存在的问题" class="headerlink" title="ZGC存在的问题"></a>ZGC存在的问题</h3><p>ZGC最大的问题是<strong>浮动垃圾</strong>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
<p>ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。              </p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<h3 id="ZGC触发时机"><a href="#ZGC触发时机" class="headerlink" title="ZGC触发时机"></a>ZGC触发时机</h3><p>ZGC目前有4中机制触发GC：</p>
<ul>
<li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。</li>
<li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li>
<li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</li>
<li>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</li>
</ul>
<h3 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h3><ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li><strong>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</strong></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/15/JVM/JVM-06-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BG1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/15/JVM/JVM-06-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BG1/" class="post-title-link" itemprop="url">垃圾回收器之G1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-15T00:00:00+08:00">2022-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:14:36" itemprop="dateModified" datetime="2022-03-27T23:14:36+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>GC Roots找新生代引用的时候，还会找老年代中对新生代有跨代引用的地方，这样的老年代对象不能算作垃圾。</p>
<p>垃圾收集器在<strong>新生代中</strong>建立了名为<strong>记忆集</strong>（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p>
<p><strong>记忆集</strong>记录了从非收集区域指向收集区域的指针集合。收集器只需要通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代指针的全部细节。</p>
<p>记忆集的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。<ul>
<li>就是处理器的寻址位数，比如常见的64位或者32位。这个精度决定了机器访问物理内存地址的指针长度。</li>
</ul>
</li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>第三种精度——“卡精度”，是通过<strong>卡表</strong>的方式实现记忆集。</p>
<p>记忆集是一种抽象的数据结构，并没有真正的实现，卡表是记忆集的一种具体实现。卡表定义了记忆集的记录精度、与堆内存的映射关系。卡表和记忆集的关系，可以类比Java中和HashMap和Map。</p>
<p>卡表最简单的形式是一个字节数组。字节数组每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块叫做<strong>卡页</strong>。卡页的大小是2的整数次幂，在HotSpot虚拟机中卡页是2^9=512字节。</p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<p>总结：新生代中维护着跨代引用的老年代对象的内存地址。这个地址通过卡表保存，卡表是记忆集的实现。卡表的数据结构是1个字节的数组，数组中每个元素都保存着一块内存的索引，这块内存叫做卡页。</p>
<h2 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First(G1)收集器"></a>Garbage First(G1)收集器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<p>一款面向服务器的垃圾收集器，针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</p>
<p>JDK9默认G1，CMS过时。</p>
<p>G1的<code>Mixed GC</code>模式：面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大</p>
<p>G1把连续的Java堆划分为<strong>多个大小相等的独立区域（Region）</strong>,将Region作为<strong>单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍。</p>
<p>每一个Region都可以根据需要扮演新生代的Eden、Survivor区或者老年代。收集器根据扮演不同角色的Region采用不同的处理策略。</p>
<p>JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER定义)，实际可以超过该值，但是不推荐。一般Region大小等于<code>堆大小除以2048</code>比如堆大小为4096M，则Region大小为2M，当然也可以用参数”<code>-XX:G1HeapRegionSize</code>“手动指定Region大小,取值范围为1MB～32MB，且应为2的N次幂，但是推荐默认的计算方式。</p>
<p>G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的Region集合。一个Region可能之前是新生代，如果Region进行了垃圾回收，一个Region可能当前是老年代，做完一次GC之后变成新生代了，可能之前是新生代，GC之后变成老年代。Region的区域功能可能会动态变化。</p>
<p>默认新生代对堆内存的占比是5%，如果堆大小为4096M，那么新生代占据200MB左右的内存，对应大概是100个Region，可以通过<code>-XX:G1NewSizePercent</code>设置新生代初始占比，在系统运行中，JVM会不停的给新生代增加更多的Region，但是**最多新生代的占比不会超过60%**，可以通过<code>-XX:G1MaxNewSizePercent</code>调整。新生代中的Eden和Survivor对应的Region数量也跟之前一样，默认8:1:1，假设新生代现在有1000个Region，Eden区对应800个，S0对应100个，S1对应100个。</p>
<p>G1收集器中还有一个<code>Humongous</code>区域，专门用来存储大对象。</p>
<p>G1对大对象的定义：大小超过了<strong>一个Region容量一半</strong>的对象。</p>
<p>超过了整个Region容量的超级大对象，会被存放在<strong>N个连续的Humongous Region</strong>之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<p>Full GC的时候会回收新生代、老年代和Humongous区。</p>
<p><img src="http://image.changzhen0212.cn/img/202201151215652.png"></p>
<h3 id="G1回收内存思路"><a href="#G1回收内存思路" class="headerlink" title="G1回收内存思路"></a>G1回收内存思路</h3><p>G1收集器将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍。这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>让G1收集器去跟踪各个Region里面的垃圾堆积的「价值」大小。</p>
<p><strong>价值</strong>：即回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的<strong>GC停顿STW时间</strong>（使用参数<code>-XX：MaxGCPauseMillis</code>指定，默认值是200毫<br>秒），优先处理回收价值收益最大的那些Region。</p>
<h3 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h3><p>类似CMS</p>
<ol>
<li>初始标记：STW，暂停所有其他线程，记录GC Roots直接能引用的对象，<strong>速度很快</strong>，同CMS </li>
<li>并发标记：同CMS并发标记。不需要STW，从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理<strong>原始快照SATB</strong>记录下的在并发时有引用变动的对象。</li>
<li>最终标记：STW，解决多标漏标，使用的是<strong>原始快照</strong>。其余同CMS </li>
<li>筛选回收：STW<ol>
<li>对各个Region的<strong>回收价值和成本进行排序，根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划</strong>、<ul>
<li>设置JVM最大停顿时间<code>-XX:MaxGCPauseMillis</code>，是初始标记、最终标记、筛选回收三个STW的总和不超过这个值。如果垃圾太多在指定时间内回收不完，在筛选回收阶段可能不会完全回收。对回收时间估算，可能只回收一半或者三分之一，把时间控制在设定的时间内，剩余的区域下个阶段再回收。<strong>为了提升用户体验</strong></li>
</ul>
</li>
<li>使用<strong>标记-复制算法</strong>，把决定回收的那一部分<strong>Region的存活对象复制到空的Region中</strong>，再清理掉整个旧Region的全部空间。由多条收集器线程并行完成。</li>
</ol>
</li>
</ol>
<p><img src="http://image.changzhen0212.cn/img/202201151237129.png"></p>
<h3 id="G1垃圾收集特点"><a href="#G1垃圾收集特点" class="headerlink" title="G1垃圾收集特点"></a>G1垃圾收集特点</h3><ul>
<li><p>G1收集器除了并发标记外，其余阶段都要完全暂停用户线程STW。</p>
</li>
<li><p>G1的回收机制是<strong>标记-复制</strong>，但是效果类似<strong>标记-整理</strong>。把标记的对象复制到相邻的空白的没有被使用过的Region，自己的Region直接清空。自身清空之后就可以变化了，之前是老年代，下次可能是新生代Eden。所以G1几乎没有内存碎片。但是大对象会使用连续的空间。</p>
</li>
<li><p>G1收集器在后台维护了一个优先列表，优先选择回收价值大的Region，比如一个Region花200ms能回收10M，另一个Region花50ms能回收20M，在回收时间有限的情况下，会优先选择后面这个Region进行回收。（判断存活对象的数量，存活的对象越多，需要复制的就越多，耗时越长）。这个时间不能胡乱设置，默认200ms，如果设置10ms，每次回收的内存非常少，最终导致满堆引发Full GC反而影响性能。</p>
</li>
</ul>
<h3 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a>G1垃圾收集分类</h3><ul>
<li><p>新生代收集 <code>Yong GC</code><br>之前学到的Eden区放满了会触发Minor GC，但是对于G1来说，5%的Eden区如果放满了会先判断清理时间是否接近配置的<strong>期望GC停顿时间</strong><code>-XX:MaxGCPauseMillis</code>或者默认的200ms，如果远远小于这个值就不会在这时触发minorGC，而是继续往空白的Region中存放对象，使Region变成新的Eden区，直到判断清理时间接近200ms，才会触发minorGC。</p>
</li>
<li><p>混合收集 <code>Mixed GC</code><br>不是Full GC，老年代的堆占有率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>设定的值则触发，回收<strong>所有的新生代</strong>和<strong>部分老年代</strong>。主要使用复制算法，如果没有足够的空Region能够承载拷贝对象，就会触发Full GC </p>
</li>
<li><p>整堆收集 <code>Full GC</code><br>STW，用单线程进行标记、清理和压缩整理。 </p>
</li>
</ul>
<h3 id="G1收集器参数"><a href="#G1收集器参数" class="headerlink" title="G1收集器参数"></a>G1收集器参数</h3><ol>
<li><code>-XX:+UseG1GC</code>:使用G1收集器</li>
<li><code>-XX:ParallelGCThreads</code>:指定GC工作的线程数量</li>
<li><code>-XX:G1HeapRegionSize</code>:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个Region</li>
<li><code>-XX:MaxGCPauseMillis</code>:目标暂停时间(默认200ms)</li>
<li><code>-XX:G1NewSizePercent</code>:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</li>
<li><code>-XX:G1MaxNewSizePercent</code>:新生代内存最大空间</li>
<li><code>-XX:TargetSurvivorRatio</code>:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</li>
<li><code>-XX:MaxTenuringThreshold</code>:最大年龄阈值(默认15)</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的Mixed GC，假如有100个格子，有45个老年代，触发Mixed GC</li>
<li><code>-XX:G1MixedGCLiveThresholdPercent</code>: 回收Region的阈值，默认85%, Region中的存活对象<strong>低于</strong>这个值时才会回收该Region，如果超过这个值，存活对象过多，回收的的意义不大。假如这个Region中有100个对象，存活着85个,15个垃圾对象，就没必要回收。如果有只有30个存活对象，其他70个垃圾对象，就可以回收了。</li>
<li><code>-XX:G1MixedGCCountTarget</code>:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会儿，然后暂停回收，恢复系统运行，一会儿再开始回收，这样可以让系统不至于单次停顿时间过长。</li>
<li><code>-XX:G1HeapWastePercent</code>:gc过程中空出来的Region是否充足阈值，默认5%，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</li>
</ol>
<h3 id="G1垃圾收集器使用场景"><a href="#G1垃圾收集器使用场景" class="headerlink" title="G1垃圾收集器使用场景"></a>G1垃圾收集器使用场景</h3><p>大内存（堆在8G以上）</p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ul>
<p>4G以下用Parellel</p>
<p>4~8G用parnew+CMS</p>
<p>8G以上用G1</p>
<h3 id="为什么G1使用SATB，CMS用增量更新"><a href="#为什么G1使用SATB，CMS用增量更新" class="headerlink" title="为什么G1使用SATB，CMS用增量更新"></a>为什么G1使用SATB，CMS用增量更新</h3><p>SATB相对增量更新，效率会更高些，当然也会造成更多的浮动垃圾，因为不需要在重新标记阶段 再次深度扫描被删除引用对象。G1由于自己的内存规划，有很多跨代扫描，要扫描的区域比CMS多，CMS就没有这么多跨代扫描。浮动垃圾对于G1不是问题，G1设计本身就会有很多浮动垃圾。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/12/JVM/JVM-05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BParNew&CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/12/JVM/JVM-05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B9%8BParNew&CMS%E4%B8%8E%E5%BA%95%E5%B1%82%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">垃圾回收器之ParNew&CMS与底层三色标记算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-12 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-12T00:00:00+08:00">2022-01-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:14:19" itemprop="dateModified" datetime="2022-03-27T23:14:19+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，是一套符合大多数程序运行实际情况的经验法则，它建立在<br>两个分代假说之上:</p>
<ul>
<li><p>  弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p>  强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
</li>
</ul>
<p>两个分代假说共同奠定了垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</p>
<ul>
<li><p>  大多数对象都是朝生夕灭，难以熬过垃圾收集过程，把它们集中放在一起，每次回收时只关注如何保留少量存活，而不是去标记那些大量将要被回收的对象</p>
</li>
<li><p>  剩下的难以消亡的对象集中放在一块，虚拟机便可以使用较低的频率来回收这个区域</p>
</li>
</ul>
<p>新生代中的对象有可能被老年代引用，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性。这样会给内存回收带来很大的性能负担。</p>
<p>由此引出第三条经验法则：</p>
<ul>
<li>  跨代引用假说（Intergenerational ReferenceHypothesis）：跨代引用相对于同代引用来说仅占极少数</li>
</ul>
<p>在此基础上，在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</p>
<h3 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h3><p>新生代使用，老年代没有用。</p>
<p>新生代内存对半分，整理前，左边随机存放对象，右边空着。整理后，把存活的对象复制到右边，左边全部清空</p>
<ul>
<li><p>  优点：实现简单，运行高效</p>
</li>
<li><p>  缺点：将可用内存缩小为了原来的一半，浪费空间</p>
</li>
</ul>
<p><img src="http://image.changzhen0212.cn/img/202201140657660.png"></p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>分为<strong>标记阶段</strong>和<strong>清除阶段</strong>。标记存活的对象，统一回收未被标记的对象（一般是这种）。也可以反过来标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。</p>
<ul>
<li><p>缺点：</p>
<ol>
<li><p> 效率问题：如果需要标记太多，效率不高</p>
</li>
<li><p> 空间问题：标记清除后产生大量不连续的内存碎片</p>
</li>
</ol>
</li>
</ul>
<p><img src="http://image.changzhen0212.cn/img/202201140703183.png"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记过程与标记-清除算法一样，但是后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存</p>
<p><img src="http://image.changzhen0212.cn/img/202201140705392.png"></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者</p>
<p><img src="http://image.changzhen0212.cn/img/202201140930589.png"></p>
<p>为什么有这么多垃圾收集器，因为他们都不够完美。从最早的Serial串行，到Parallel并行，再到CMS是一个不断完善的过程。到目前为止也没有一个完美的垃圾收集器</p>
<h3 id="垃圾收集器的并发和并行"><a href="#垃圾收集器的并发和并行" class="headerlink" title="垃圾收集器的并发和并行"></a>垃圾收集器的并发和并行</h3><p>联系垃圾收集器的上下文语境</p>
<ul>
<li>并行（Parallel）：并行描述的是<strong>多条垃圾收集器线程之间的关系</strong>，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li>并发（Concurrent）：并发描述的是<strong>垃圾收集器线程与用户线程之间的关系</strong>，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</li>
</ul>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC <span class="comment">// 新生代</span></span><br><span class="line">-XX:+UseSerialOldGC <span class="comment">// 老年代</span></span><br></pre></td></tr></table></figure>

<p>是最基本、历史最悠久的垃圾收集器。是<strong>单线程</strong>的，只会用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作时候必须暂停其他工作线程，STW stop the world，直到收集结束</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201141030642.png"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC // 新生代</span><br><span class="line">-XX:+UseParallelOldGC // 老年代</span><br></pre></td></tr></table></figure>

<p>就是Serial的<strong>多线程</strong>版本, 默认收集线程数跟cpu核数相同，通过<code>-XX:ParallelGCThreads</code> 指定收集线程数，通常不推荐修改。</p>
<p><strong>对比Parallel和CMS</strong></p>
<ul>
<li><p>Parallel收集器关注点是吞吐量（高效利用CPU），STW的时间会比较长。</p>
</li>
<li><p>CMS关注点更多是用户线程停顿时间，STW时间比较短，提高用户体验</p>
</li>
</ul>
<p><strong>吞吐量：cpu中用于运行用户代码的时间与cpu总消耗时间的比值</strong></p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201141039037.png"></p>
<p>CMS是老年代的收集器，无法与CMS配合使用，因此有了ParNew</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:UseParNewGC</span><br></pre></td></tr></table></figure>



<p>跟Parallel很类似，区别主要是它可以和CMS收集器配合使用。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201141035758.png"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC // 老年代</span><br></pre></td></tr></table></figure>

<p><strong>使用标记-清除算法</strong></p>
<p>整个垃圾回收过程主要是5步：</p>
<ol>
<li><p>初始标记：会做STW，用可达性分析算法，从GC Roots出发，标记所有能<strong>直接引用的对象（只找直接引用的，间接引用的不找），速度很快。</strong></p>
<p><strong>为什么要STW？</strong>：如果不STW，不断地有新的局部变量引用新的对象，初始标记就永远做不完了</p>
</li>
<li><p>并发标记：不需要STW，并发标记阶段就是上一步从GC Roots的直接关联对象出发，一直找，遍历整个对象图。<strong>这个过程耗时较长，整个GC过程中时间最长，大概占整个GC时间的80%<strong>，但是不需要停顿用户线程，用户线程可以跟垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致</strong>已经标记过的对象状态发生改变</strong>。</p>
<p>可能之前不是垃圾，等并发标记结束时候，就变成垃圾了；也有可能之前是垃圾对象，等并发标记结束之后又被引用了，变成非垃圾。</p>
</li>
<li><p>重新标记：会STW，修复并发标记时候状态改变的对象，停顿时间比初始标记阶段稍长，远远比并发标记阶段时间短，主要是用<strong>三色标记算法</strong> </p>
</li>
<li><p>并发清理：不需要STW，用户线程和垃圾收集线程并行把标记的对象保留，没有标记的对象清除掉。这个阶段如果有新增对象，会标记为黑色，不做任何处理（<strong>三色标记算法</strong>） </p>
</li>
<li><p>并发重置：重置本次GC过程的标记数据。下次会重新标记。</p>
</li>
</ol>
<p><img src="http://image.changzhen0212.cn/img/202201141046413.png"></p>
<p><strong>CMS对比Parallel</strong></p>
<p>整个垃圾收集的过程CMS&gt;Parallel，但是CMS的stop the world时间要远远小于Parallel，用户体验很好。</p>
<p>Parallel更在乎吞吐量，CMS牺牲了整个垃圾收集过程的时间，换来STW时间更短，提高了用户体验度。</p>
<p>CMS的优点：并发收集、低停顿；</p>
<p>CMS的缺点：</p>
<ul>
<li><p>对cpu资源敏感，会和服务抢资源 </p>
</li>
<li><p>无法处理<strong>浮动垃圾</strong></p>
<ul>
<li>浮动垃圾：在并发清理阶段，清理没有被标记的对象，可能在某一个区域清理完之后之后又new了一个对象，这个对象又变成垃圾了，这样的对象清理不了，只能等下一次GC清理，这种叫做浮动垃圾。下次GC就会干掉。</li>
</ul>
</li>
<li><p>使用的回收算法是”<strong>标记-清除</strong>“算法会产生大量的空间碎片。可以通过设置参数<code>-XX:UserCMSCompactAtFullCollection</code>让jvm在执行完标记清除后再做整理 </p>
</li>
<li><p>有一个很大的问题 <strong>“concurrent mode failure” 并发模式失败</strong>。</p>
<p>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发。特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许还没回收完就会触发full GC。此时就会进入stop the word，<strong>用serial old垃圾收集器来回收，效率会非常低。</strong></p>
<ul>
<li>场景：老年代快满了或者已经满了，此时在做并发标记或者并发清理时，用户线程还在执行，此时如果有一个大对象，老年代放不下了，就会stop the word，用serial old垃圾收集器来回收。</li>
</ul>
</li>
</ul>
<h4 id="CMS核心参数"><a href="#CMS核心参数" class="headerlink" title="CMS核心参数"></a>CMS核心参数</h4><p>Java的命令，有类似 <code>java -version</code>，一个”-“的参数，有 <code>java -X</code> 一个”X”的参数，有<code>java -XX</code> 两个”X”的参数，X越多代表命令越不稳定，将来的版本可能会把这些参数废除掉。X不是说性能不稳定，而是说在这个版本可用，但是这些功能将来的版本可能不支持</p>
<p>老年代不会真的满了之后才触发FullGC，不配置参数，默认是到92%触发FullGC。</p>
<ol>
<li><p><code>-XX:+UseConcMarkSweepGC</code>：启用cms </p>
</li>
<li><p><code>-XX:ConcGCThreads</code>：并发的GC线程数</p>
</li>
<li><p><code>-XX:+UseCMSCompactAtFullCollection</code>：FullGC之后做压缩整理（减少碎片）,碎片整理也会stop the world，跟剩余存活对象数量有关，剩得越少效率越高，剩得越多效率越低。</p>
</li>
<li><p><code>-XX:CMSFullGCsBeforeCompaction</code>：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次。配3代表每3次FullGC压缩一次 (3,4通常一起配)。如果频繁full gc就2，3次一次。如果不频繁就配0 。</p>
</li>
<li><p><code>-XX:CMSInitiatingOccupancyFraction</code>: 当老年代使用达到该比例时会触发FullGC（默认是92，是百分比）。这个参数为了避免<strong>并发模式失败</strong>，具体根据机器配置去配，如果是高配可以适当调高，低配适当调低。如果配得太低，比如80，可能会导致老年代有20%永远用不到，浪费了资源。</p>
</li>
<li><p><code>-XX:+UseCMSInitiatingOccupancyOnly</code>：只使用设定的回收阈值(<code>-XX:CMSInitiatingOccupancyFraction</code>设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整。</p>
</li>
<li><p><code>-XX:+CMSScavengeBeforeRemark</code>：在CMS GC前启动一次minor gc，目的在于减少老年代对新生代的引用，降低CMS GC标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段。<strong>如果老年代和新生代有跨代的地方，CMS做标记的时候要标过去，如果在GC之前先MinorGC一次，就不用去新生代标记了，加快并发标记阶段</strong>跨代引用很少，配不配意义不大，Full GC会优先做老年代的收集，然后做MinorGC。</p>
<p><strong>对象跨代</strong>：<code>Math math = new Math()</code> math对象已经挪到老年代了，但是它引用的user对象（User作为Math类的属性）还在新生代，还没有挪到老年代，user是math的成员变量，math对象中存储的是user对象的地址，user对象没有在math对象内部 </p>
</li>
<li><p><code>-XX:+CMSParallellnitialMarkEnabled</code>：表示在初始标记的时候多线程执行，缩短STW。</p>
</li>
<li><p><code>-XX:+CMSParallelRemarkEnabled</code>：在重新标记的时候多线程执行，缩短STW。</p>
</li>
</ol>
<h2 id="垃圾收集算法底层实现"><a href="#垃圾收集算法底层实现" class="headerlink" title="垃圾收集算法底层实现"></a>垃圾收集算法底层实现</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>在并发标记过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，<strong>多标记</strong>和<strong>漏标记</strong>的情况就可能发生。标记的是非垃圾对象。</p>
<p>把遍历对象图过程中遇到的对象，按照**”是否访问过”**这个条件标记成白色、黑色、灰色三种颜色。</p>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，而且这个<strong>对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。<strong>黑色对象不可能直接（不经过灰色对象）指向某个白色对象</strong>。</li>
<li>灰色：表示对象以及被垃圾收集器访问过，但这个对象上至少有存在一个引用还没有被扫描过。</li>
</ul>
<p>一句话总结：默认都是白色，黑色代表分析完了，灰色代表分析过但是还没分析完。如果GC Roots可达性分析完了，还存在白色，白色就要被回收</p>
<p><img src="http://image.changzhen0212.cn/img/202201141344491.png"></p>
<p>看图，此时是在并发标记<strong>过程中</strong>，A中引用B，B中引用了C和D，C被扫描了，D还没有被扫描到，</p>
<p>B中因为同时有已经扫描的C和未被扫描的D，所以B是灰色。D未扫描是白色，之后可能会变黑，C没有其他引用，就相当于它的所有成员变量都被扫描到了，所以是黑色。</p>
<p>程序继续运行，可能出现一种情况，b.d=null, a.d=d。 b是灰色的，b中对d的引用设为空，从b就不会再扫描到d了，a是黑色的，虽然a引用了d，但是黑色不会再扫描。所以此时的d还是白色的，不会被扫描到。虽然它是白色的，但它不是垃圾对象。</p>
<p>按照三色标记，d会被清除掉，但它不是垃圾对象，这种就属于<strong>漏标</strong>。</p>
<p><strong>漏标</strong>通过读写屏障解决，有两种方案:</p>
<ol>
<li>增量更新：在做并发标记的时候，新增的引用用一个集合存起来，重新标记阶段，会对新增的引用重新扫描（把新增引用的源头A标记为灰色，重新扫描，就可以发现D了。重新标记的时候会STW）</li>
<li>原始快照(SATB)：并发标记阶段，不会去管新增的引用，而是管之前B引用D，在赋值之前，把老的引用保存一个快照，放到一个集合中。在重新标记阶段时候，找到快照的目标扫描，把快照的目标都标记为黑色。此时如果A没有引用D，此时D就是个浮动垃圾，下次会被回收。</li>
</ol>
<p>增量更新和原始快照都是通过<strong>写屏障</strong>实现的</p>
<p>所有的新增、删除引用，都是通过赋值操作。写屏障，在<strong>赋值操作前</strong>或者在<strong>赋值操作后</strong>，加入一些处理（类似AOP）。</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span></span>&#123;</span><br><span class="line">	<span class="built_in">pre_write_barrier</span>(field); <span class="comment">// 写屏障-写前操作</span></span><br><span class="line">    *field = new_value;</span><br><span class="line">    <span class="built_in">post_write_barrier</span>(field, value); <span class="comment">// 写屏障-写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>写屏障实现SATB</strong>，在赋值操作之前，把旧的值放到remark</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_write_barrier</span><span class="params">(oop* field)</span></span>&#123;</span><br><span class="line">    oop old_value = *field; <span class="comment">//获取旧值</span></span><br><span class="line">    remark_set.<span class="built_in">add</span>(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>写屏障实现增量更新</strong>，在赋值操作之后，把新的引用记录下来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span></span>&#123;</span><br><span class="line">    remark_set.<span class="built_in">add</span>(new_value); <span class="comment">//记录新引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>写屏障是用队列实现的</strong>，为什么用队列呢</p>
<p>频繁的写操作，如果写屏障要是出了问题，会影响写操作。</p>
<p>把写屏障放到队列里异步处理，不能用同步操作，提升性能。</p>
<p>垃圾收集器都是针对<strong>堆</strong>的，元空间几乎是没什么可回收的</p>
<p>不同的垃圾收集器对于漏标的处理方式不同</p>
<ul>
<li><p>CMS：写屏障-增量更新</p>
</li>
<li><p>G1，Shenandoah：写屏障-原始快照SATB</p>
</li>
<li><p>ZGC：读屏障</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/11/JVM/JVM-04-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/11/JVM/JVM-04-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">字节码结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-11T00:00:00+08:00">2022-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:13:54" itemprop="dateModified" datetime="2022-03-27T23:13:54+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jvm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@author</span> ChangZhen */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过javap-verbose反编译"><a href="#通过javap-verbose反编译" class="headerlink" title="通过javap -verbose反编译"></a>通过<code>javap -verbose</code>反编译</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Classfile /d:/idea_projects/Demo/jvm-demo/target/classes/com/example/jvm/ByteCodeDemo<span class="variable">.class</span></span><br><span class="line">  <span class="comment">// 最后修改日期；文件大小</span></span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">1</span>-<span class="number">10</span>; size <span class="number">555</span> bytes</span><br><span class="line">  <span class="comment">// 文件的md5值</span></span><br><span class="line">  MD5 checksum <span class="number">67</span>f23efe87b076af663419bd6163a1a6</span><br><span class="line">  <span class="comment">//.class文件是通过哪个源文件编译过来的</span></span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeDemo.java&quot;</span></span><br><span class="line"><span class="comment">// 字节码的详细信息    </span></span><br><span class="line">public <span class="keyword">class</span> com<span class="variable">.example</span><span class="variable">.jvm</span><span class="variable">.ByteCodeDemo</span></span><br><span class="line">  <span class="comment">// JDK的次版本号</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  <span class="comment">// JDK的主版本号</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  <span class="comment">// 访问权限</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line"><span class="comment">// 常量池</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4</span>.#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3</span>.#<span class="number">21</span>         <span class="comment">// com/example/jvm/ByteCodeDemo.userName:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">22</span>            <span class="comment">// com/example/jvm/ByteCodeDemo</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               userName</span><br><span class="line">   #<span class="number">6</span> = Utf8               Ljava/lang/String;</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/example/jvm/ByteCodeDemo;</span><br><span class="line">  #<span class="number">14</span> = Utf8               getUserName</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">16</span> = Utf8               setUserName</span><br><span class="line">  #<span class="number">17</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               ByteCodeDemo<span class="variable">.java</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// userName:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               com/example/jvm/ByteCodeDemo</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  private java<span class="variable">.lang</span><span class="variable">.String</span> userName;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  public com<span class="variable">.example</span><span class="variable">.jvm</span><span class="variable">.ByteCodeDemo</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo;</span><br><span class="line">  <span class="comment">// get方法</span></span><br><span class="line">  public java<span class="variable">.lang</span><span class="variable">.String</span> getUserName();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field userName:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">4</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo;</span><br><span class="line">  <span class="comment">// set方法</span></span><br><span class="line">  public <span class="keyword">void</span> setUserName(java<span class="variable">.lang</span><span class="variable">.String</span>);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field userName:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> userName   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;ByteCodeDemo.java&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="打开class文件，用二进制文件查看"><a href="#打开class文件，用二进制文件查看" class="headerlink" title="打开class文件，用二进制文件查看"></a>打开class文件，用二进制文件查看</h3><p>文件结构是单个字节来显示，1byte=8bit，8位可以用两个16进制数表示</p>
<table>
<thead>
<tr>
<th>进制</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>十六进制 Hex</td>
<td>FF</td>
</tr>
<tr>
<td>十进制 DEC</td>
<td>255</td>
</tr>
<tr>
<td>八进制 OCT</td>
<td>377</td>
</tr>
<tr>
<td>二进制 BIN</td>
<td>1111 1111</td>
</tr>
</tbody></table>
<p><img src="http://image.changzhen0212.cn/img/202201100944443.png"></p>
<h3 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h3><p><img src="http://image.changzhen0212.cn/img/202201101016188.png"></p>
<p>查看class文件方法，二进制打开，看tags标识位，然后看class_index指向的是常量池名称和方法描述符</p>
<p>常量池中看tags，然后是length，表示后面多少位是此常量池的数据。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池可以看作class文件里的资源仓库(比如Java类定的方法和变量信息), 类的信息的描述信息都是通过索引去常量池中获取。</p>
<p>常量池中主要存放两大类常量：<strong>字面量（Literal）</strong>和<strong>符号引用（Symbolic References）</strong></p>
<ul>
<li><p>字面量：比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值、基本数据类型等。</p>
</li>
<li><p>符号引用：属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<p><img src="http://image.changzhen0212.cn/img/202201102114093.png"></p>
<h3 id="描述信息"><a href="#描述信息" class="headerlink" title="描述信息"></a>描述信息</h3><p>JVM规范中，每个字段或者变量都有<strong>描述信息</strong>，描述信息主要有：<strong>数据类型，方法参数列表,返回值类型</strong>等。<br>基本参数类型和void类型都是用一个大写的字符来表示，对象类型是通过一个大写L加全类名表示，这么做的好处就是在保证jvm能读懂class文件的情况下尽量的压缩class文件体积</p>
<ul>
<li>基本数据类型表示:<ul>
<li>B—-&gt;byte</li>
<li>C—-&gt;char</li>
<li>D—-&gt;double </li>
<li>F—–&gt;float</li>
<li>I——&gt;int</li>
<li>J——&gt;long</li>
<li>S——&gt;short</li>
<li>Z——&gt;boolean</li>
<li>V——-&gt;void</li>
</ul>
</li>
<li>对象类型:<ul>
<li><p>String——&gt;Ljava/lang/String;(后面有一个分号)</p>
</li>
<li><p>对于数组类型: 每一个唯独都是用一个前置 [ 来表示，比如: </p>
<ul>
<li><p>int[] ——&gt;<code>[I</code></p>
</li>
<li><p>String [][]——&gt;<code>[[Ljava.lang.String;</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>用描述符来描述方法,先参数列表，后返回值的格式，参数列表按照严格的顺序放在()中<br>比如：源码 <code>String getUserInfoByIdAndName(int id,String name)</code> 的方法描述符号<br><code>(I,Ljava/lang/String;)Ljava/lang/String;</code></p>
<h2 id="逐行分析class文件"><a href="#逐行分析class文件" class="headerlink" title="逐行分析class文件"></a>逐行分析class文件</h2><p>第一行：</p>
<p>00~03 CA FE BA BE 魔数</p>
<p>04~05 00 00 次版本号,对应反编译代码中 第6行minor version: 0`</p>
<p>06~07 00 34 十进制=52 JDK8,对应反编译代码中 第7行 <code>major version: 52</code></p>
<p>08 09 00 18 常量池开始 十进制=24，常量池长度为24，对应反编译代码中第9行<code>Constant pool</code>，<code>Constant pool</code>只有1~23，因为第0个被jvm占用了表示为null</p>
<p>从第一行偏移量0A，常量池开始</p>
<p>第一个常量：0A,tag=0A=十进制的10，查表得此常量是<code>CONSTANT_Methodref_info</code>,常量类型为方法引用。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量类型为方法引用</span></span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">    u1 tag=10; <span class="comment">// 值为10</span></span><br><span class="line">    u2 class_index; <span class="comment">// 指向声明方法的类描述符CONSTANT_Class_info的索引项</span></span><br><span class="line">    u2 name_and_type_index; <span class="comment">//指向名称及类型描述符CONSTANT_NameAndType的索引项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以常量共5个字节: 0A 00 04 00 14</p>
<ul>
<li>00 04两个字节表示<strong>方法所在类</strong>，指向反编译文件中 常量池索引#4 <code>#4 = Class  #23  // java/lang/Object</code></li>
<li>然后#4的常量类型是Class，是符号引用类型，指向常量池#23的位置,</li>
<li>#23是常量池类型的字面量<code>#23 = Utf8  java/lang/Object</code>。</li>
</ul>
<ul>
<li>00 14两个字节表示<strong>方法的描述符</strong>，十进制值=20，指向反编译文件中 常量池索引#20 <code>#20 = NameAndType     #7:#8</code></li>
<li>然后#20常量类型是<code>NameAndType</code>类型属于引用类型，指向常量池的#7 #8位置</li>
<li>#7 常量是UTF-8类型属于字面量值为:<code>&lt;init&gt; </code>为构造方法</li>
<li>#8 常量是UTF-8类型的字面量值为:<code>()V</code></li>
</ul>
<p><strong>所以常量池中的第一个常量是：<code>java/lang/Object.&quot;&quot;:()V</code></strong></p>
<p>第二个常量：09,tag=09，查表得此常量是<code>CONSTANT_Fieldref_info</code>,</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info&#123;</span><br><span class="line">    u1 tag=9; <span class="comment">// 值为9</span></span><br><span class="line">    u2 class_index; <span class="comment">//指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</span></span><br><span class="line">    u2 name_and_type_index; <span class="comment">//指向字段描述符CONSTANT_NameAndType的索引项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以常量共5个字节：09 00 03 00 15</p>
<ul>
<li>00 03两个字节表示方法所在类，指向反编译文件中，常量池索#3 <code>#3 = Class  #22 // com/example/jvm/ByteCodeDemo</code></li>
<li>#3的常量类型是Class，是符号引用，指向常量池中#22位置</li>
<li>#22是常量池中字面量 <code>#22 = Utf8   com/example/jvm/ByteCodeDemo</code>。</li>
</ul>
<ul>
<li>00 15两个字节表示字段的名称和类型，15的十进制值=21，指向常量池索引#21 <code>#21 = NameAndType     #5:#6      // userName:Ljava/lang/String;</code></li>
<li>#21的常量类型是<code>NameAndType</code>，引用类型，指向#5 #6</li>
<li>#5 常量是UTF-8类型属于字面量值为: userName</li>
<li>#6 常量是UTF-8类型的字面量值为: Ljava/lang/String;</li>
</ul>
<p><strong>所以第二个常量是：<code>com/example/jvm/ByteCodeDemo.userName:Ljava/lang/String;</code></strong></p>
<h3 id="常量池查看总结："><a href="#常量池查看总结：" class="headerlink" title="常量池查看总结："></a>常量池查看总结：</h3><ol>
<li><p>先看第一位u1的值，去表中查询对应的<code>tag</code></p>
</li>
<li><p>根据tag确定常量池结构类型，常量池的几种结构类型：</p>
<ol>
<li>类或者接口描述符索引</li>
<li>CONSTANT_NameAndType索引</li>
<li>字符串占用的字节数</li>
<li>方法句柄类型</li>
<li>常量池索引</li>
</ol>
<p>……</p>
</li>
<li><p>根据常量池结构类型和占用大小，确定反编译文件的入口索引</p>
</li>
<li><p>根据入口索引即可定位到常量池的具体字面量</p>
</li>
</ol>
<p><img src="http://image.changzhen0212.cn/img/202201100944443.png"></p>
<h3 id="class文件结构（前半部分）"><a href="#class文件结构（前半部分）" class="headerlink" title="class文件结构（前半部分）"></a>class文件结构（前半部分）</h3><p><img src="http://image.changzhen0212.cn/img/202201101016188.png"></p>
<p>上一节分析了两个常量池，后续的常量池大同小异，不再分析。</p>
<p>常量池结束是在22行偏移量06处结束。</p>
<p><strong>编译出来的是静态常量池，程序启动时会加载到运行时常量池中</strong></p>
<p>22行07开始是访问标识符号。</p>
<h2 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h2><p><img src="http://image.changzhen0212.cn/img/202201110644988.png"></p>
<p>访问标识符占用二个字节: 00 21，查表并没有21，所以此处是两个值通过位运算<code>或</code>得出的。0x0021 = 0x0020|0x0001 位运算。所以class的访问权限标识符是<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>。对应反编译代码中flags。</p>
<h2 id="类索引、父类索引"><a href="#类索引、父类索引" class="headerlink" title="类索引、父类索引"></a>类索引、父类索引</h2><p>接下来是类索引、父类索引分别占用两个字节：00 03 00 04</p>
<p><img src="http://image.changzhen0212.cn/img/202201110651827.png"></p>
<p>对应常量池索引#3，#4，分别指向当前类和父类的名字</p>
<p><img src="http://image.changzhen0212.cn/img/202201110656468.png"></p>
<p>得出当前类为<code>com/example/jvm/ByteCodeDemo</code>，父类为<code>java/lang/Object</code></p>
<h2 id="接口信息"><a href="#接口信息" class="headerlink" title="接口信息"></a>接口信息</h2><p>当前演示类没有实现接口，换一个类演示</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@author</span> ChangZhen */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCodeDemo2</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userName = userName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Classfile /d:/idea_demo_projects/jvm-demo/target/classes/com/example/jvm/ByteCodeDemo2.class</span><br><span class="line">  Last modified <span class="number">2022</span><span class="number">-1</span><span class="number">-11</span>; size <span class="number">613</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">118</span>ca8b8caec9229b71b14cb472da634</span><br><span class="line">  Compiled from <span class="string">&quot;ByteCodeDemo2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">jvm</span>.<span class="title">ByteCodeDemo2</span> <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Cloneable</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>:</span> <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">22</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">23</span>         <span class="comment">// com/example/jvm/ByteCodeDemo2.userName:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">24</span>            <span class="comment">// com/example/jvm/ByteCodeDemo2</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">25</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">26</span>            <span class="comment">// java/io/Serializable</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">27</span>            <span class="comment">// java/lang/Cloneable</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               userName</span><br><span class="line">   #<span class="number">8</span> = Utf8               Ljava/lang/String;</span><br><span class="line">   #<span class="number">9</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">10</span> = <span class="built_in">Utf8</span>               ()V</span><br><span class="line">  #<span class="number">11</span> = Utf8               Code</span><br><span class="line">  #<span class="number">12</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">13</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">14</span> = Utf8               <span class="keyword">this</span></span><br><span class="line">  #<span class="number">15</span> = Utf8               Lcom/example/jvm/ByteCodeDemo2;</span><br><span class="line">  #<span class="number">16</span> = Utf8               getUserName</span><br><span class="line">  #<span class="number">17</span> = <span class="built_in">Utf8</span>               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               setUserName</span><br><span class="line">  #<span class="number">19</span> = <span class="built_in">Utf8</span>               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">21</span> = Utf8               ByteCodeDemo2.java</span><br><span class="line">  #<span class="number">22</span> = NameAndType        #<span class="number">9</span>:#<span class="number">10</span>         <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// userName:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">24</span> = Utf8               com/example/jvm/ByteCodeDemo2</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/io/Serializable</span><br><span class="line">  #<span class="number">27</span> = Utf8               java/lang/Cloneable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> java.lang.String userName;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.example.jvm.<span class="built_in">ByteCodeDemo2</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field userName:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">4</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field userName:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/example/jvm/ByteCodeDemo2;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span> userName   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;ByteCodeDemo2.java&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="字节码二进制"><a href="#字节码二进制" class="headerlink" title="字节码二进制"></a>字节码二进制</h3><p><img src="http://image.changzhen0212.cn/img/202201110700860.png"></p>
<h3 id="分析接口计数器"><a href="#分析接口计数器" class="headerlink" title="分析接口计数器"></a>分析接口计数器</h3><p>26行开始，00 02 00 05 00 06 前两个字节是接口标识位，表示实现了几个接口。后四个字节指向常量池中索引，是具体实现的接口</p>
<p>实现的第一个接口：00 05，指向常量池索引 #5, <code>#5 = Class  #26       // java/io/Serializable</code></p>
<p>#5 指向 #26 <code>java/io/Serializable</code></p>
<p>实现的第二个接口：00 06，指向常量池索引 #6，<code>#6 = Class  #27       // java/lang/Cloneable</code></p>
<p>#6 指向 #27 <code>java/lang/Cloneable</code></p>
<p><img src="http://image.changzhen0212.cn/img/202201110704586.png"></p>
<p><img src="http://image.changzhen0212.cn/img/202201110707841.png"></p>
<p><img src="http://image.changzhen0212.cn/img/202201110946440.png"></p>
<p>对比一开始没有实现接口的class，紧挨着父类索引的是两个字节 00 00。</p>
<p>所以用<code>00 00</code>表示此类没有实现的接口</p>
<p><strong>由于java记录实现接口数量是由两个字节记录，所以java最多可以实现 FFFF = 十进制 65535 个接口</strong></p>
<h2 id="字段表信息"><a href="#字段表信息" class="headerlink" title="字段表信息"></a>字段表信息</h2><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>分析文件回到一开始没有实现接口的class</strong></p>
<p>22行紧接着接口00 00 后面的是 00 01 00 02 00 05 00 06 00 00</p>
<p>00 01 表示只有一个字段，也就是代码中的userName</p>
<p><img src="http://image.changzhen0212.cn/img/202201110955407.png"></p>
<h3 id="字段表结构"><a href="#字段表结构" class="headerlink" title="字段表结构"></a>字段表结构</h3><p><img src="http://image.changzhen0212.cn/img/202201111002486.png"></p>
<p>00 02 表示字段权限修饰符，查下表得字段为 <code>ACC_PRIVATE</code>,即字段为 private修饰，与代码中一致</p>
<p><img src="http://image.changzhen0212.cn/img/202201111000068.png"></p>
<p>00 05 00 06 分别是字段名称索引 和 字段描述索引</p>
<p>对应常量池中的 #5 和 #6</p>
<p><img src="http://image.changzhen0212.cn/img/202201111010459.png"></p>
<p>00 00 是属性表个数 这里为0表示后面是没有属性表集合</p>
<p>所以字段的全描述符是</p>
<p><code>ACC_PRIVATE Ljava/lang/String; userName</code></p>
<h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>紧接着是方法表部分。00 03 表示有3个方法。</p>
<p>使用jclasslib查看验证</p>
<p><img src="http://image.changzhen0212.cn/img/202201111017546.png"></p>
<h3 id="方法表结构"><a href="#方法表结构" class="headerlink" title="方法表结构"></a>方法表结构</h3><p><img src="http://image.changzhen0212.cn/img/202201111013178.png"></p>
<p>第一个方法的前8个字节</p>
<p>00 01 00 07 00 08 00 01</p>
<p>00 01 表示方法的权限修饰符是 <code>ACC_PUBLIC</code></p>
<p>00 07 表示方法名称，指向常量池#7 <code>#7 = Utf8  &lt;init&gt;</code>,<code>&lt;init&gt;</code>表示<strong>构造方法</strong></p>
<p>00 08 表示字段描述符索引，指向常量池#8 <code>#8 = Utf8  ()V</code>,表示<strong>无参无返回值</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111029311.png"></p>
<p>00 01表示有一个方法属性的个数</p>
<h4 id="方法表中的属性表attribute-info"><a href="#方法表中的属性表attribute-info" class="headerlink" title="方法表中的属性表attribute_info"></a>方法表中的属性表attribute_info</h4><p><strong>结构</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111031746.png"></p>
<p>紧挨着之后的6个字节 00 09 00 00 00 2F</p>
<p>00 09 表示属性名称索引，指向常量池#9 <code> #9 = Utf8  Code</code>,<strong>表示是Code属性</strong></p>
<p>00 00 00 2F 是属性长度，2F=十进制47，表示占据47个字节作为code的值，后续47个字节是Code属性占用的字节，<strong>这47个字节从Code属性表中第三个开始也就是<code>max_stack</code>开始</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111044619.png"></p>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p><strong>Code属性表的结构</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111049530.png"></p>
<p><strong>00 01</strong> 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 01: <code>max_stack</code> 表示最大操作数栈深度为1</p>
<hr>
<p>00 01 <strong>00 01</strong> 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 01: <code>max_locals</code>，表示的是局部变量表变量的个数为1</p>
<hr>
<p>00 01 00 01 <strong>00 00 00 05</strong> 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 00 00 05: <code>Code_lenth</code>，表示指令的长度为5，接下来5个字节是指令</p>
<hr>
<p>00 01 00 01 00 00 00 05 <strong>2A B7 00 01 B1</strong> 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>2A B7 00 01 B1：<code>code</code></p>
<ul>
<li>2A: 字节码注记符是aload_0，当前调用方法的栈帧中的局部变量表索引位置为0的局部变量压入到操作数栈的栈顶</li>
<li>B7：表示是 invokespecial 调用父类的方法，后面需要接入二个字节表示调用哪个方法</li>
<li>00 01：指向常量池中 #1 <code>\#1 = Methodref      #4.#20     // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li>
<li>B1： 对应的字节码指令值retrun，表示<code>retrun void from method；</code></li>
</ul>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 <strong>00 00</strong> 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 00：表示方法没有抛出异常</p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 <strong>00 02</strong> 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 02：<code>Code_attribute</code>，表示结构中属性表的个数为2个</p>
<p><img src="http://image.changzhen0212.cn/img/202201111116533.png"></p>
<hr>
<p><strong>LineNumberTable属性结构</strong></p>
<p>所以接下来8个字节是LineNumberTable表</p>
<p><img src="http://image.changzhen0212.cn/img/202201111118374.png"></p>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 <strong>00 0A</strong> 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 0A：属性名称的索引，指向常量池中#10,<code>#10 = Utf8        LineNumberTable</code></p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A <strong>00 00 00 06</strong></p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 00 00 06：属性长度，后面6个字节是属性内容</p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p><strong>00 01 00 00 00 04</strong> 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<ul>
<li>00 01： 表示的是有1对指令码和源码映射关系</li>
<li>00 00 00 04：表示第一个指令映射的是源码中第4行代码，也就是构造方法</li>
</ul>
<p><img src="http://image.changzhen0212.cn/img/202201111124241.png"></p>
<hr>
<p>后面紧挨着的是LocalVariableTable</p>
<p><strong>LocalVariableTable属性结构</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111127196.png"></p>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 <strong>00 0B</strong> 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 0B：本地变量表的名称索引，指向常量池#11 <code>#11 = Utf8        LocalVariableTable</code></p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B <strong>00 00 00 0C</strong> 00 01 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 00 00 0C：<code>attribute_length</code>，本地变量表中属性的长度=12</p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C <strong>00 01</strong> 00 00 00 05 00 0C 00 0D 00 00</p>
<p>00 01：<code>local_variable_table_length</code>，本地变量表个数=1</p>
<hr>
<p>然后紧跟着是local_variable_info项目结构</p>
<p><strong>local_variable_info项目结构</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201111132857.png"></p>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 <strong>00 00 00 05</strong> 00 0C 00 0D 00 00</p>
<p>00 00：<code>start_pc</code>，局部变量的生命周期开始的字节码偏移量=0</p>
<p>00 05：<code>length</code>,局部变量的作用范围覆盖的长度=5</p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 <strong>00 0C</strong> 00 0D 00 00</p>
<p>00 0C：表示局部变量的名称，指向常量池#12 <code>#12 = Utf8        this</code></p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C <strong>00 0D</strong> 00 00</p>
<p>00 0D：表示局部变量描述符索引，指向常量池#13 <code>#13 = Utf8        Lcom/example/jvm/ByteCodeDemo;</code></p>
<hr>
<p>00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 02 00 0A 00 00 00 06</p>
<p>00 01 00 00 00 04 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D <strong>00 00</strong></p>
<p>00 00：<code>index</code>，是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个</p>
<p>至此，第一个方法字节码分析结束</p>
<p>后两个方法大同小异。方法表结束之后就是最后一部分class文件属性</p>
<h2 id="class文件的属性"><a href="#class文件的属性" class="headerlink" title="class文件的属性"></a>class文件的属性</h2><p>最后10个字节 00 01 00 12 00 00 00 02 00 13</p>
<p>00 01：<code>attribute_count</code>,表示class文件只有1个属性</p>
<p>SourceFile属性用于记录生成这个Class文件的源码文件名称</p>
<h3 id="SourceFile属性结构"><a href="#SourceFile属性结构" class="headerlink" title="SourceFile属性结构"></a>SourceFile属性结构</h3><p><img src="http://image.changzhen0212.cn/img/202201111309642.png"></p>
<p>00 12: 属性名索引，指向常量池#18, <code>#18 = Utf8    SourceFile</code></p>
<p>00 00 00 02：属性长度，表示属性接下来的长度为2。</p>
<p>00 13：源文件索引，指向常量池#19，<code> #19 = Utf8    ByteCodeDemo.java</code></p>
<p>至此class字节码文件分析结束。</p>
<h2 id="class文件整体结构图"><a href="#class文件整体结构图" class="headerlink" title="class文件整体结构图"></a>class文件整体结构图</h2><p><img src="http://image.changzhen0212.cn/img/202201111439872.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/09/JVM/JVM-03-JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/09/JVM/JVM-03-JVM%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">JVM对象创建与内存分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-09T00:00:00+08:00">2022-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:12:11" itemprop="dateModified" datetime="2022-03-27T23:12:11+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="创建一个对象的流程"><a href="#创建一个对象的流程" class="headerlink" title="创建一个对象的流程"></a>创建一个对象的流程</h2><ol>
<li>类加载检查</li>
<li>判断是否加载过、解析、初始化过。<ul>
<li>如果没有加载会去加载类</li>
</ul>
</li>
<li>分配内存<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
</li>
<li>初始化：给成员变量设置默认初始值</li>
<li>设置对象头</li>
<li>执行<code>&lt;init&gt;</code>方法</li>
</ol>
<p><img src="http://image.changzhen0212.cn/img/202201091613955.png"></p>
<h3 id="分配内存方法"><a href="#分配内存方法" class="headerlink" title="分配内存方法"></a>分配内存方法</h3><ul>
<li>指针碰撞：内存空间分配是规则的，有一个已使用和未使用的临界指针，正常情况下是，把指针往后挪一定的空间，空出来的位置存放对象，这个叫做<strong>指针碰撞</strong></li>
<li>空闲列表：内存分配不规则，已被使用的内存和空闲的内存相互交错在一起，虚拟机维护一个列表，记录可用的内存空间，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，叫做<strong>空闲列表</strong></li>
</ul>
<p>不管是哪种内存划分，都会有并发的问题，每个线程创建对象都会在堆中存放，会对内存做争抢，解决并发问题有两种方式</p>
<ul>
<li><strong>CAS+失败重试</strong>：大家一起抢空间，只能有一个线程抢到，没抢到的再去其他空间抢</li>
<li>**本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)**：给每一个线程在堆里事先规划一块独立的线程专属内存空间，线程在new对象时，只向自己的内存空间存放。可以通过<code>-XX：+/-UseTLAB</code>参数来设定是否使用TLAB，<code>-XX:TLABSize</code> 指定TLAB大小，有默认大小通常不需要指定</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将分配到的内存空间（不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>Hotspot虚拟机中，对象在内存中存储布局可以分三块区域：对象头、实例数据、对齐填充</p>
<p><img src="http://image.changzhen0212.cn/img/202201082223222.png"></p>
<p>对象头Object Header主要包含：</p>
<ol>
<li>Mark Word标记字段，32位虚拟机占4个字节，64位虚拟机占8个字节</li>
<li>Klass Point类型指针，开启指针压缩栈4字节，关闭指针压缩占8字节</li>
<li>数组长度，4个字节，只有数组对象才有</li>
</ol>
<p><img src="http://image.changzhen0212.cn/img/202201091622057.png"></p>
<h4 id="Mark-Word-标记字段"><a href="#Mark-Word-标记字段" class="headerlink" title="Mark Word 标记字段"></a>Mark Word 标记字段</h4><p><strong>32位MarkWord</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201082226093.png"></p>
<p><strong>64位MarkWord</strong></p>
<p><img src="http://image.changzhen0212.cn/img/202201082228773.png"></p>
<h4 id="Klass-Pointer-类型指针"><a href="#Klass-Pointer-类型指针" class="headerlink" title="Klass Pointer 类型指针"></a>Klass Pointer 类型指针</h4><p>类的元数据指针，一个new出来的对象放在堆里，对象头中的klass指针指向的是方法区中类的类元数据信息。</p>
<p>一个<code>.class</code>文件，加载到方法区的是类的<code>类元信息</code>，类的对象信息存在堆中，获取类的数据时，访问的是堆中的对象信息，JVM内部调用C++实现的类型指针访问方法区中的<code>.class</code>。</p>
<p>一句话总结：堆中的对象是方法区中类元信息的入口。</p>
<p><strong>指针压缩</strong></p>
<p>开启指针压缩占4字节，关闭占8字节。</p>
<p>指针默认开启，关闭需要配置<code>-XX:UseCompressedOops</code></p>
<p>不开启指针压缩，对象放到堆里会给堆造成很大压力，可能会频繁触发Full GC。</p>
<p>32位系统最多支持2^32内存，4G；</p>
<p>64位系统最多支持2^64内存。</p>
<p>2^32=4G, 2^33=16G, 2^34=32G</p>
<p>JVM只处理了最大32G的内存，如果堆内存在32G以上会使指针压缩失效。不建议堆内存大于32G</p>
<h3 id="执行-lt-init-gt-方法"><a href="#执行-lt-init-gt-方法" class="headerlink" title="执行&lt;init&gt;方法"></a>执行<code>&lt;init&gt;</code>方法</h3><p>给对象属性真正的赋值(是由程序员赋的值)，调用对象构造方法。</p>
<h2 id="对象内存分配流程"><a href="#对象内存分配流程" class="headerlink" title="对象内存分配流程"></a>对象内存分配流程</h2><ol>
<li>new一个对象，对象<strong>逃逸分析</strong>，非逃逸的对象尝试在栈上分配，如果栈放不下还是在堆上分配。</li>
<li>如果在堆上分配，优先放入Eden区<ol>
<li>判断是否是大对象，如果是大对象，直接进入老年代</li>
<li>做TLAB线程分配缓冲，然后放入Eden区</li>
</ol>
</li>
<li>长期存活的对象进入老年代<ul>
<li>从Eden出生的对象，经过一次minor gc存活，并且可以被Survivor区容纳，会被放入Survivor区，对象分代年龄设为1，每熬过一次minor gc，分代年龄就会+1，当分代年龄达到一定程度(最大是15，可以配置)时，就会晋升到老年代。对象晋升到老年代的阈值可通过参数<code>-XX:MaxTenuringThreshold</code>设置</li>
</ul>
</li>
</ol>
<h3 id="大对象："><a href="#大对象：" class="headerlink" title="大对象："></a>大对象：</h3><p>整个Eden区放不下的直接算作是大对象（比如Eden区10兆，对象占20兆，直接扔老年代）。一个对象本身占用比较大，又不会被回收掉，在新生代会频繁触发minor gc，所以直接放入老年代，把新生代空出来放更多的对象。</p>
<p>设置JVM参数：<code>-XX:PretenureSizeThreshold</code>可以设置大对象的大小。如果超过这个大小直接进入老年代，不会进入新生代，这个参数只有在Serial和ParNew两个收集器下有效，G1收集器对大对象有自己的定义。</p>
<h3 id="对象逃逸分析"><a href="#对象逃逸分析" class="headerlink" title="对象逃逸分析"></a>对象逃逸分析</h3><p>上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比两个方法，方法test1()返回user对象，test2()没有返回。test1的user作用范围逃逸出了当前方法，test2的user对象作用范围没有逃逸出当前方法。没有逃逸的对象，有几种优化：栈上分配、标量替换、同步消除</p>
<p>开启逃逸分析参数 <code>-XX:+DoEscapeAnalysis</code>,JDK7之后默认开启。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>没有逃逸的对象，可以尝试着把test2的user对象分配到栈帧，在方法结束之后就直接释放掉了。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><ul>
<li>标量：不可被进一步分解的量，就是java的基本数据类型，int、long等数值类型以及refrence类型。</li>
<li>聚合量：标量的对立，可以被进一步分解的量，比如java的对象。</li>
</ul>
<p>一个对象经过逃逸分析，能确定这个对象可以在栈上分配了，分配对象需要一块连续的空间，而栈帧剩余的空间没有一块连续的空间，都是碎片空间。此时JVM会进行标量替换，只把成员变量放到栈帧，把一个对象打散成成员属性，放到栈帧。会有一个标识，标记在这些成员变量是属于这个对象的。</p>
<p>一句话：栈上分配的对象，把聚合量分解成标量放到栈帧中。</p>
<h3 id="老年代空间分配担保"><a href="#老年代空间分配担保" class="headerlink" title="老年代空间分配担保"></a>老年代空间分配担保</h3><p>在新生代做Minor GC之前，虚拟机会检查，<strong>老年代的连续空间</strong>是否<strong>大于新生代对象总大小</strong>或者<strong>历次晋升的平均大小</strong></p>
<ul>
<li>是-&gt;进行Minor GC</li>
<li>否-&gt;Full GC。</li>
</ul>
<h2 id="对象内存回收机制"><a href="#对象内存回收机制" class="headerlink" title="对象内存回收机制"></a>对象内存回收机制</h2><ul>
<li>引用计数器：在对象中添加一个引用计数器，每当有一个地方引用它时（被引用），计数器+1，当引用失效时计数器-1。当计数器为0时就可以被回收了。<ul>
<li>缺点：如果AB相互循环引用，就永远不会被回收。</li>
</ul>
</li>
<li>可达性分析：通过<code>GC Roots</code>作为起始节点集合，从这些节点开始，根据引用关系向下搜索，搜索过程中的路径称为<strong>引用链</strong>。如果某个对象到GC Roots间没有任何引用链相连，或者说GC Roots到这个对象不可达，则证明这个对象不再被使用，就可以被回收了。</li>
</ul>
<p>可作为GC Roots的对象包括以下几种:</p>
<ul>
<li>栈中引用的对象。</li>
<li>静态变量</li>
<li>本地方法栈中Native方法引用的对象</li>
<li>字符串常量池</li>
<li>被synchronized关键字持有的对象</li>
<li>虚拟机内部引用，比如系统类加载器、异常对象(Exception)等</li>
</ul>
<h3 id="常见的引用类型"><a href="#常见的引用类型" class="headerlink" title="常见的引用类型"></a>常见的引用类型</h3><p>常见的引用类型分为：强引用、软引用、弱引用、虚引用，强度依次逐渐减弱。</p>
<ul>
<li><p>强引用：就是代码中最普遍的引用赋值，比如Object obj = new Object();</p>
<ul>
<li>只要强引用关系存在，就不会回收掉被引用的对象</li>
</ul>
</li>
<li><p>软引用：还在用但是非必须的对象。正常情况不会被回收，但是GC之后发现还是放不出空间存放新对象，就会把软引用回收。用<code>SoftReference</code>类包裹。<code>软引用可以用来实现内存敏感的高速缓存</code></p>
<p>软引用在实际中有重要应用，比如浏览器的后退按钮，点击后退时候显示的网页内容是重新请求还是从缓存中获取，要看具体的实现策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li>
<li><p>弱引用：非必须对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。使用<code>WeakReference</code>包裹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></table></figure></li>
<li><p>虚引用：也称为”幽灵引用”或者”幻影引用”，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。几乎没用</p>
<p>为一个对象设置虚引用关联的<strong>唯一目的</strong>只是为了能在这个对象被收集器回收时收到一个系统通知。使用<code>PhantomReference</code>包裹。</p>
</li>
</ul>
<h3 id="对象实现了Object的finalize-方法最终判定对象是否存活"><a href="#对象实现了Object的finalize-方法最终判定对象是否存活" class="headerlink" title="对象实现了Object的finalize()方法最终判定对象是否存活"></a>对象实现了Object的<code>finalize()</code>方法最终判定对象是否存活</h3><p>要真正宣告一个对象死亡，至少要经历两次标记过程。</p>
<ol>
<li>第一次标记，对象在进行可达性分析后发现没有于<code>GC Roots</code>相连接的引用链。</li>
<li>第二次标记：筛选，条件是此对象是否<strong>有必要</strong>执行<code>finalize()</code>方法<ul>
<li>如果没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，就没有必要执行，直接宣告对象死亡</li>
<li>如果有必要执行，会放置在F-Queue队列中，执行finalize()方法，方法中重新与引用链上任何一个对象关联即可。</li>
</ul>
</li>
</ol>
<p>finalize()只会被调用一次，也就是说这种自救的机会只有一次。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区中主要回收两部分内容：废弃的常量和无用的类</p>
<ul>
<li>废弃常量：假如一个字符串”java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是”java”，即已经没有任何字符串对象引用常量池中的”java”常量，且虚拟机中也没有其他地方引用这个字面量，就会在下一次内存回收时候清理出常量池</li>
<li>无用的类：需要同时满足三个条件<ol>
<li>该类的所有实例都已经被回收，java堆中不存在这个类的和子类的任何实例</li>
<li>加载该类的类加载器已经被回收。<ul>
<li>JVM自己内部的classLoader不会被回收，所以由这三个类加载器加载的类基本不会被回收。</li>
<li>自定义类加载器，比如tomcat创建的jsp类加载器会被回收，而且是一定要被回收掉。</li>
</ul>
</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在审核地方通过反射方式访问类的方法。</li>
</ol>
</li>
</ul>
<h2 id="对象的整体内存布局"><a href="#对象的整体内存布局" class="headerlink" title="对象的整体内存布局"></a>对象的整体内存布局</h2><p><img src="http://image.changzhen0212.cn/img/202201091623723.png"></p>
<p><img src="http://image.changzhen0212.cn/img/202201091630230.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/08/JVM/JVM-02-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/08/JVM/JVM-02-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JVM内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-08T00:00:00+08:00">2022-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 23:11:15" itemprop="dateModified" datetime="2022-03-27T23:11:15+08:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JVM内存分布"><a href="#JVM内存分布" class="headerlink" title="JVM内存分布"></a>JVM内存分布</h2><p>JVM虚拟机主要分三大块：类装载子系统、运行时数据区、字节码执行引擎</p>
<ul>
<li>类装载子系统：把类的数据从class文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程。</li>
<li>运行时数据区：JVM的内存模型，最最核心。</li>
<li>字节码执行引擎：虚拟机方法调用和字节码执行。解析命令，提交给操作系统执行。</li>
</ul>
<p>三者之间的关系：</p>
<p>一个字节码文件，通过类装载子系统，丢到运行时数据区，最后通过字节码执行引擎来执行内存区中的代码。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM运行时数据区主要分为：堆、栈、方法区(元空间)、本地方法栈、程序计数器。</p>
<p>其中，堆、方法区是所有线程共享。栈、本地方法栈、程序计数器是每个线程独有的。</p>
<p><img src="http://image.changzhen0212.cn/img/202201072027762.png" alt=" "></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>官方叫做<strong>虚拟机栈</strong>，线程私有，生命周期与线程相同，所以也可以叫做线程栈。栈描述的是Java方法执行的线程内存模型。</p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>虚拟机进行方法调用和方法执行背后的数据结构，存放局部变量表、操作数栈、动态连接、方法出口等信息。</p>
<p>一句话总结：<strong>一个方法，对应着一块栈帧</strong></p>
<p>一个类的方法，只要开始运行它，就有一个主线程运行方法，只要有一个线程运行main方法，java虚拟机会在线程栈的一大块内存空间，给当前线程分配一小块独立的内存空间，用来存放当前线程中需要用到的局部变量的内存空间，这个线程栈只能存放自己线程内部的局部变量。</p>
<p>假设又来了一个线程，java虚拟机会在线程栈的一大块内存空间，再分配一小块独立内存空间给这个线程，存放线程的局部变量。</p>
<p>所以不同线程之间的局部变量是互不影响的，每个线程都有自己的内存空间存放自己的局部变量。</p>
<h3 id="虚拟机栈和数据结构的栈有什么区别"><a href="#虚拟机栈和数据结构的栈有什么区别" class="headerlink" title="虚拟机栈和数据结构的栈有什么区别"></a>虚拟机栈和数据结构的栈有什么区别</h3><ul>
<li><p>数据结构的栈：后进先出(Last In First Out，LIFO)。</p>
</li>
<li><p>虚拟机栈：存放栈帧，结构就是数据结构的栈，后进先出。每次都从栈顶取，符合java代码的执行流程，后调用的方法先释放掉(出栈)</p>
</li>
</ul>
<p>如果方法重复调用，是在栈内存中不断地往上分配栈帧，而不是套娃</p>
<h3 id="栈帧的结构："><a href="#栈帧的结构：" class="headerlink" title="栈帧的结构："></a>栈帧的结构：</h3><ul>
<li>局部变量表：存放方法参数和方法内部定义的局部变量。编译期确定最大容量,Code#max_locals<ul>
<li>第0位存放的是<code>this</code></li>
</ul>
</li>
<li>操作数栈：内部也是栈结构，后进先出，存放的是具体的操作数，是变量对应的值。编译期确定最大深度，Code#max_stacks</li>
<li>动态连接：每个栈帧都包含一个指向常量池中该栈帧所属方法的引用。字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用在每一次运行期间都转化为直接引用，就是动态连接。<ul>
<li>与之相对应的是静态连接，在类加载阶段或者第一次调用时就被转化为直接引用</li>
</ul>
</li>
<li>方法出口：根据方法出口里保存的信息，可以知道返回到main()方法里面，继续从哪一行代码进行</li>
</ul>
<p>通常new一个对象是放到堆里面（也可能通过逃逸分析在栈中分配，暂不考虑。）;<code>new Math();</code></p>
<p>现在Math math 局部变量表中有一个math。</p>
<p>此时堆里的math和局部变量表里的math的关系，局部变量表里的math是一块空的内存空间，并不是真正的math，存放的是堆中的math的内存地址，就是指针。</p>
<p><img src="http://image.changzhen0212.cn/img/202201081553374.png"></p>
<h3 id="栈的内存分配"><a href="#栈的内存分配" class="headerlink" title="栈的内存分配"></a>栈的内存分配</h3><p>是给一个线程分配的,512K或者1M就可以, <code>-Xss</code>设置的越小，count值就越小，说明一个线程栈可以分配的栈帧就越少，但是对于JVM整体来说，能开启的线程数会更多。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>同样是每一个线程独有的，每个线程都有的一块内存空间，用于记录即将执行的代码的内存地址，或者叫做行号。</p>
<p>每执行完一行代码，<strong>字节码执行引擎</strong>会马上动态地修改程序计数器的值。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>各个线程共享的内存区域</p>
<p>JDK8之前叫做永久代，之后叫做元空间。</p>
<p>存储已被虚拟机加载的 类型信息、常量、静态变量、类元信息等。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><code>javap -v</code> 生成的汇编指令可以看到常量池，常量池是放到方法区里的，叫做<strong>运行时常量池</strong>，常量池有很多，还有八大类型的，字符串常量池。</p>
<p>符号在程序真正开始运行时，会加载到内存中，这些静态的常量池加载到内存中会变成运行时常量池。</p>
<h3 id="类元信息"><a href="#类元信息" class="headerlink" title="类元信息"></a>类元信息</h3><p>编译器编译后的代码信息，就是类的信息</p>
<h3 id="元空间的内存分配"><a href="#元空间的内存分配" class="headerlink" title="元空间的内存分配"></a>元空间的内存分配</h3><p>元空间使用的是直接内存，也就是物理内存。如果不设置，默认可以把剩余的物理内存全部用完，默认初始值是21M。元空间满了会触发Full GC，会回收掉方法区一些无用的对象。</p>
<p>方法区有一个容量分配大小的自动扩容机制</p>
<p>如果达到了21M触发了full gc</p>
<ul>
<li>回收后元空间变为1m，这个21M会被调小，可能到15M</li>
<li>回收后元空间几乎没有变化，这个21M会被调大，可能会变30M或者40M</li>
</ul>
<p>设置元空间大小，可以加快war包部署，一般推荐初始和最大值都设置256M</p>
<p><strong>可以认为线程栈和方法区都是使用操作系统的直接内存，非堆内存。</strong></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>线程私有，每一个线程都有自己的本地方法栈</p>
<p>存放的是本地方法 native修饰的，底层是C或者C++实现的。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有线程共享的内存区域，唯一目的就是存放对象实例。</p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>两个分代假说：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>基于以上两种分代假说，将堆内存分为新生代、老年代。新生代中又分为Eden区、Survivor区，Survivor区又分为From Survivor区、To survivor区</p>
<p><img src="http://image.changzhen0212.cn/img/202201081542827.png"></p>
<p>默认情况下分配比例，比例都是可配置的</p>
<ul>
<li>年轻代和老年代的比例为1:2，新生代为1/3，老年代为2/3</li>
<li>新生代中，Eden:S0:S1 = 8:1:1</li>
</ul>
<h2 id="GC整体过程"><a href="#GC整体过程" class="headerlink" title="GC整体过程"></a>GC整体过程</h2><p>大多数对象都是朝生夕灭的，一个对象new出来之后，通常是放到Eden区的（也不一定全是，比如大对象后面讨论）。</p>
<p>Eden区满了会触发minor gc，通过可达性分析标记出非垃圾对象，这些非垃圾对象赋值到S0区，剩下的全部干掉。经过这一轮GC之后，对象的分代年龄会+1。</p>
<p>程序继续运行，Eden区又满了，又触发minor gc，此时GC回收Eden区和S0区，将Eden区中存活的对象和S0区存活的对象都复制到S1区，所有对象分代年龄+1，Eden区和S0区对象干掉。</p>
<p>程序继续运行，Eden区又满了，触发GC，回收的是Eden区和Survivor区中的非空区域，存活下来的对象挪到Survivor区的空区域，分代年龄+1。</p>
<p>新生代中存活的对象会在S0和S1区挪来挪去，当分代年龄达到15（不同垃圾收集器的值设置不同，最大是15，对象头中用4位保存对象头，最大是15）时还没释放掉，对象会被挪到老年代。</p>
<h3 id="哪些对象会挪到老年代"><a href="#哪些对象会挪到老年代" class="headerlink" title="哪些对象会挪到老年代"></a>哪些对象会挪到老年代</h3><p>静态变量的对象、对象池、缓存、缓存对象、Spring容器中的对象，From Survivor区放不下的对象等…</p>
<p>如果老年代满了，就会触发Full GC，此时回收的是整个堆的对象。如果老年代还是满的，之后再放就会触发(out of memory OOM)</p>
<p>GC时会触发(Stop The World, STW)，不管是Minor GC还是 Full GC都会触发，会停止所有的用户线程。</p>
<p>JVM调优主要是为了减少GC，更多的是减少Full GC，Full GC的垃圾收集时间比较长，STW的时间也会比较长。</p>
<h3 id="JVM为什么要设计STW"><a href="#JVM为什么要设计STW" class="headerlink" title="JVM为什么要设计STW"></a>JVM为什么要设计STW</h3><p><strong>能不能不停止用户线程，让用户继续操作比如下单、加购物车</strong></p>
<p>GC的过程主要是收集一些非垃圾对象，如果不停止用户线程，用户线程执行完了还没完成垃圾收集，之前标记的非垃圾对象，现在已经变成垃圾对象了。可能几十万的对象标记都白做了。</p>
<h3 id="不同的垃圾回收名词"><a href="#不同的垃圾回收名词" class="headerlink" title="不同的垃圾回收名词"></a>不同的垃圾回收名词</h3><p>垃圾收集主要分为 部分收集(Partial GC)和整堆收集(Full GC)。部分收集又分出新生代收集、老年代收集、混合收集</p>
<ul>
<li>部分收集(Partial GC)<ul>
<li>新生代收集(Minor GC/Young GC)：新生代的垃圾收集</li>
<li>老年代收集(Major GC/Old GC)：目前Major GC说法有些混淆，有时候单指老年代收集有时候又指的是整堆收集Full GC</li>
<li>混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集，只有G1收集器有这种行为</li>
</ul>
</li>
<li>整堆收集(Full GC):收集整个Java堆和方法区</li>
</ul>
<h2 id="从内存分配的角度看类加载"><a href="#从内存分配的角度看类加载" class="headerlink" title="从内存分配的角度看类加载"></a>从内存分配的角度看类加载</h2><p>类加载器，也是放在堆中的，因为类加载器就是一个对象。对象就要放在堆里。</p>
<p>类加载到内存中</p>
<ul>
<li>class对象放在堆中</li>
<li>类型信息(类元信息)放在元空间中，是C的对象。</li>
<li>堆中对象的的对象头中存有指针，指向元空间C底层的对象，元空间中的这个对象，对class对象有一个引用</li>
</ul>
<h2 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆：</span></span><br><span class="line"><span class="attr">-Xms</span></span><br><span class="line"><span class="attr">-Xmx</span></span><br><span class="line"><span class="comment"># 新生代（年轻代）</span></span><br><span class="line"><span class="attr">-Xmn</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#方法区</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MetaspaceSize # 元空间初始值</span></span><br><span class="line"><span class="meta">-XX</span>:<span class="string">MaxMetaspaceSize #元空间最大值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line"><span class="attr">-Xss</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2022/01/07/JVM/JVM-01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/07/JVM/JVM-01-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">类加载过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-07T00:00:00+08:00">2022-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-28 00:27:27" itemprop="dateModified" datetime="2022-03-28T00:27:27+08:00">2022-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java技术栈</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E6%8A%80%E6%9C%AF%E6%A0%88/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="通过java命令执行代码流程"><a href="#通过java命令执行代码流程" class="headerlink" title="通过java命令执行代码流程"></a>通过java命令执行代码流程</h2><ol>
<li>首先通过java指令调用jvm.dll文件，创建java虚拟机(c++实现)。dll文件就相当于java的jar包，包含很多的库函数、代码实现。</li>
<li>启动java虚拟机过程中，创建<code>引导类加载器</code>（c++实现，所以java中的引导类加载器是null）</li>
<li>通过c++调用java虚拟机的真正的启动程序<code>sum.misc.Lancher</code>。通过这个类调用<code>launcer.getClassLoader()</code>可以创建java的其他类加载器。Launcher类是java虚拟机的启动器。</li>
<li>通过jvm的类加载器，调用<code>loadClass</code>方法加载磁盘里的<code>.class</code>字节码文件</li>
<li>加载完成字节码文件后，调用main方法，最终会调用到c的Main方法，执行代码</li>
<li>销毁jvm</li>
</ol>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280016071.png"></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>其中，<code>launcher.loadClass()</code>类加载过程，可以细分为：</p>
<p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<ol>
<li>加载：将class文件加载到内存中。</li>
<li>验证：验证class文件的格式</li>
<li>准备：静态变量赋值，比如int=0;boolean=false,引用=null，由虚拟机规定，和最终值无关</li>
<li>解析：静态链接，将符号引用转为直接引用。符号就是一些关键字、类名、方法等，把符号加载到内存中，内存地址就是直接引用。虚拟机可以运行</li>
<li>初始化：将静态变量的初始化为指定值。比如int从0变为666</li>
</ol>
<p>类加载通常都是懒加载，比如war包和jar包，不会一次性加载到内存中，而是真正使用时候再去加载。</p>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280016095.png"></p>
<h2 id="构造方法、静态代码块先后顺序"><a href="#构造方法、静态代码块先后顺序" class="headerlink" title="构造方法、静态代码块先后顺序"></a>构造方法、静态代码块先后顺序</h2><p>构造方法在静态代码块之后</p>
<ul>
<li>静态代码块是在类加载时候执行</li>
<li>构造方法是在类加载完成后执行</li>
</ul>
<h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><ol>
<li>引导类加载器-BootstrapClassLoader:c++实现，加载JRE目录下的核心类库</li>
<li>扩展类加载器-ExtClassLoader，加载扩展jar包，ext目录下的jar</li>
<li>应用程序类加载器-AppClassLoader，加载自己写的类</li>
<li>自定义类加载器</li>
</ol>
<h2 id="父子类加载器"><a href="#父子类加载器" class="headerlink" title="父子类加载器"></a>父子类加载器</h2><p>所有的类加载器都继承自ClassLoader，父子类加载器并不是继承关系，parent是通过代码维护关系。</p>
<p>每个类加载器都有个parent，ExtClassLoader的parent是BootstrapClassLoader，AppClassLoader的parent是ExtClassLoader。自定义类加载器的parent是AppClassLoader</p>
<p>Launcher类是单例的，加载时就初始化好。主要工作就是把Ext和App两个类加载器构造出来，并且把它们之间的关系构建好。</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>一个类，先从AppClassLoader加载。</p>
<ol>
<li>AppClassLoader先看自己是否已经加载了<ul>
<li>如果已加载就返回</li>
<li>如果没有委托给ExtClassLoader</li>
</ul>
</li>
<li>ExtClassLoader看自己是否已经加载了<ul>
<li>如果已加载就返回</li>
<li>如果没有委托给BootstrapClassLoader</li>
</ul>
</li>
<li>BootstrapClassLoader看自己是否加载了<ul>
<li>如果已加载就返回</li>
<li>如果没有，就去lib包下找这个类<ul>
<li>找到就加载</li>
<li>找不到就委托给ExtClassLoader</li>
</ul>
</li>
</ul>
</li>
<li>ExtClassLoader从ext包下找这个类，<ul>
<li>如果找到就加载</li>
<li>找不到委托给AppClassLoader</li>
</ul>
</li>
<li>AppClassLoader开始加载这个类。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/changzhen0212/picGo/master/blog/202203280017441.png"></p>
<h3 id="为什么从AppClassLoader开始加载呢"><a href="#为什么从AppClassLoader开始加载呢" class="headerlink" title="为什么从AppClassLoader开始加载呢"></a>为什么从AppClassLoader开始加载呢</h3><p>web应用程序大部分的类都是AppClassLoader加载的，只有第一次加载时比较慢，之后直接从AppClassLoader中获取</p>
<h3 id="为什么设计双亲委派"><a href="#为什么设计双亲委派" class="headerlink" title="为什么设计双亲委派"></a>为什么设计双亲委派</h3><ul>
<li>沙箱安全机制</li>
<li>防止类被重复加载</li>
</ul>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>自定义类加载器，重写类加载方法，实现自己的加载逻辑，不委派给父加载器加载。</p>
<h3 id="Tomcat的类加载机制"><a href="#Tomcat的类加载机制" class="headerlink" title="Tomcat的类加载机制"></a>Tomcat的类加载机制</h3><p>如果两个war包一个是spring4，一个是spring5，会有相同的包名和类名，只会加载一个，要解决版本问题。</p>
<p>tomcat7之后，会给每个war包生成一个单独的类加载器，有几个war包就生成几个WebAppClassLoader，打破双亲委派，war包中的类用自己类加载器，不向上委托。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://changzhen0212.github.io/2021/08/29/Hexo/Hexo-Next%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_icon.jpg">
      <meta itemprop="name" content="ChangZhen">
      <meta itemprop="description" content="不忘初心，方得始终">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ChangZhen's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/29/Hexo/Hexo-Next%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">Hexo Next主题创建标签和分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-29 00:07:24 / 修改时间：00:23:38" itemprop="dateCreated datePublished" datetime="2021-08-29T00:07:24+08:00">2021-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="添加分类页"><a href="#添加分类页" class="headerlink" title="添加分类页"></a>添加分类页</h2><p>新建一个页面，命名为<code>categories</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>此时会在<code>hexo</code>根目录下的<code>source</code>目录下，新建<code>categories</code>文件夹，编辑文件夹中的<code>index.md</code>，将页面的类型设置为categories，主题将自动为这个页面显示所有分类</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2021-08-28 23:53:50</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>编辑主题的 <code>_config.yml</code>，将<code>menu</code>下的<code>categories</code>取消注释</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure>



<h2 id="添加文章分类关联"><a href="#添加文章分类关联" class="headerlink" title="添加文章分类关联"></a>添加文章分类关联</h2><p><code>hexo</code>中有<code>Front-matter</code>这个概念，是文件最上方以 — 分隔的区域，用于指定个别文件的变量。举个栗子，在<code>hexo new post title</code>时会生成<code>title.md</code>文件，文件生成好的文章属性。在其中添加<code>categories</code>属性，再部署之后就可以在分类页看到分类了。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo next 为文章添加分类</span><br><span class="line">date: 2021-08-29 00:07:24</span><br><span class="line">tags: Hexo</span><br><span class="line">categories: Hexo</span><br><span class="line">--- </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>categories:</code> 与后面的分类直接需要保留一个空格</p>
</blockquote>
<h3 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: MySQL索引</span><br><span class="line">date: 2021-08-28 15:29:30</span><br><span class="line">tags: MySQL</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> Java技术栈</span><br><span class="line"><span class="bullet">-</span> MySQL</span><br></pre></td></tr></table></figure>



<h2 id="修改模板"><a href="#修改模板" class="headerlink" title="修改模板"></a>修改模板</h2><p>修改<code>hexo</code>根目录下<code>scaffolds</code>目录下的<code>post.md</code>文件，新增一行<code>categories</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line"><span class="section">categories:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>之后再执行新建笔记命令<code>hexo new &quot;title&quot;</code>时，模板会自动添加<code>categories</code>属性。</p>
<h3 id="添加标签tags同理"><a href="#添加标签tags同理" class="headerlink" title="添加标签tags同理"></a>添加标签tags同理</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ChangZhen"
      src="/images/head_icon.jpg">
  <p class="site-author-name" itemprop="name">ChangZhen</p>
  <div class="site-description" itemprop="description">不忘初心，方得始终</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChangZhen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
